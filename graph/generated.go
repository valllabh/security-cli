// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/valllabh/security-cli/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	Auth             func(ctx context.Context, obj interface{}, next graphql.Resolver, password *model.AuthRule, query *model.AuthRule, add *model.AuthRule, update *model.AuthRule, delete *model.AuthRule) (res interface{}, err error)
	CacheControl     func(ctx context.Context, obj interface{}, next graphql.Resolver, maxAge int) (res interface{}, err error)
	Cascade          func(ctx context.Context, obj interface{}, next graphql.Resolver, fields []*string) (res interface{}, err error)
	Custom           func(ctx context.Context, obj interface{}, next graphql.Resolver, http *model.CustomHTTP, dql *string) (res interface{}, err error)
	Dgraph           func(ctx context.Context, obj interface{}, next graphql.Resolver, typeArg *string, pred *string) (res interface{}, err error)
	Generate         func(ctx context.Context, obj interface{}, next graphql.Resolver, query *model.GenerateQueryParams, mutation *model.GenerateMutationParams, subscription *bool) (res interface{}, err error)
	GoTag            func(ctx context.Context, obj interface{}, next graphql.Resolver, key string, value *string) (res interface{}, err error)
	HasInverse       func(ctx context.Context, obj interface{}, next graphql.Resolver, field string) (res interface{}, err error)
	Id               func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Lambda           func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	LambdaOnMutate   func(ctx context.Context, obj interface{}, next graphql.Resolver, add *bool, update *bool, delete *bool) (res interface{}, err error)
	Remote           func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	RemoteResponse   func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string) (res interface{}, err error)
	Search           func(ctx context.Context, obj interface{}, next graphql.Resolver, by []model.DgraphIndex) (res interface{}, err error)
	Secret           func(ctx context.Context, obj interface{}, next graphql.Resolver, field string, pred *string) (res interface{}, err error)
	WithSubscription func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	AddLicensePayload struct {
		License func(childComplexity int, filter *model.LicenseFilter, order *model.LicenseOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddPackagePayload struct {
		NumUids func(childComplexity int) int
		Package func(childComplexity int, filter *model.PackageFilter, order *model.PackageOrder, first *int, offset *int) int
	}

	AddPackageTypePayload struct {
		NumUids     func(childComplexity int) int
		PackageType func(childComplexity int, filter *model.PackageTypeFilter, order *model.PackageTypeOrder, first *int, offset *int) int
	}

	AddPackageVersionPayload struct {
		NumUids        func(childComplexity int) int
		PackageVersion func(childComplexity int, filter *model.PackageVersionFilter, order *model.PackageVersionOrder, first *int, offset *int) int
	}

	AddProgrammingLanguagePayload struct {
		NumUids             func(childComplexity int) int
		ProgrammingLanguage func(childComplexity int, filter *model.ProgrammingLanguageFilter, order *model.ProgrammingLanguageOrder, first *int, offset *int) int
	}

	DeleteLicensePayload struct {
		License func(childComplexity int, filter *model.LicenseFilter, order *model.LicenseOrder, first *int, offset *int) int
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
	}

	DeletePackagePayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		Package func(childComplexity int, filter *model.PackageFilter, order *model.PackageOrder, first *int, offset *int) int
	}

	DeletePackageTypePayload struct {
		Msg         func(childComplexity int) int
		NumUids     func(childComplexity int) int
		PackageType func(childComplexity int, filter *model.PackageTypeFilter, order *model.PackageTypeOrder, first *int, offset *int) int
	}

	DeletePackageVersionPayload struct {
		Msg            func(childComplexity int) int
		NumUids        func(childComplexity int) int
		PackageVersion func(childComplexity int, filter *model.PackageVersionFilter, order *model.PackageVersionOrder, first *int, offset *int) int
	}

	DeleteProgrammingLanguagePayload struct {
		Msg                 func(childComplexity int) int
		NumUids             func(childComplexity int) int
		ProgrammingLanguage func(childComplexity int, filter *model.ProgrammingLanguageFilter, order *model.ProgrammingLanguageOrder, first *int, offset *int) int
	}

	License struct {
		ID func(childComplexity int) int
	}

	LicenseAggregateResult struct {
		Count func(childComplexity int) int
		IDMax func(childComplexity int) int
		IDMin func(childComplexity int) int
	}

	MultiPolygon struct {
		Polygons func(childComplexity int) int
	}

	Mutation struct {
		AddLicense                func(childComplexity int, input []*model.AddLicenseInput, upsert *bool) int
		AddPackage                func(childComplexity int, input []*model.AddPackageInput) int
		AddPackageType            func(childComplexity int, input []*model.AddPackageTypeInput, upsert *bool) int
		AddPackageVersion         func(childComplexity int, input []*model.AddPackageVersionInput, upsert *bool) int
		AddProgrammingLanguage    func(childComplexity int, input []*model.AddProgrammingLanguageInput, upsert *bool) int
		DeleteLicense             func(childComplexity int, filter model.LicenseFilter) int
		DeletePackage             func(childComplexity int, filter model.PackageFilter) int
		DeletePackageType         func(childComplexity int, filter model.PackageTypeFilter) int
		DeletePackageVersion      func(childComplexity int, filter model.PackageVersionFilter) int
		DeleteProgrammingLanguage func(childComplexity int, filter model.ProgrammingLanguageFilter) int
		UpdatePackage             func(childComplexity int, input model.UpdatePackageInput) int
	}

	Package struct {
		Languages          func(childComplexity int, filter *model.ProgrammingLanguageFilter, order *model.ProgrammingLanguageOrder, first *int, offset *int) int
		LanguagesAggregate func(childComplexity int, filter *model.ProgrammingLanguageFilter) int
		Licenses           func(childComplexity int, filter *model.LicenseFilter, order *model.LicenseOrder, first *int, offset *int) int
		LicensesAggregate  func(childComplexity int, filter *model.LicenseFilter) int
		Name               func(childComplexity int) int
		Type               func(childComplexity int, filter *model.PackageTypeFilter) int
		URL                func(childComplexity int) int
		Versions           func(childComplexity int, filter *model.PackageVersionFilter, order *model.PackageVersionOrder, first *int, offset *int) int
		VersionsAggregate  func(childComplexity int, filter *model.PackageVersionFilter) int
	}

	PackageAggregateResult struct {
		Count   func(childComplexity int) int
		NameMax func(childComplexity int) int
		NameMin func(childComplexity int) int
		URLMax  func(childComplexity int) int
		URLMin  func(childComplexity int) int
	}

	PackageType struct {
		ID func(childComplexity int) int
	}

	PackageTypeAggregateResult struct {
		Count func(childComplexity int) int
		IDMax func(childComplexity int) int
		IDMin func(childComplexity int) int
	}

	PackageVersion struct {
		ID func(childComplexity int) int
	}

	PackageVersionAggregateResult struct {
		Count func(childComplexity int) int
		IDMax func(childComplexity int) int
		IDMin func(childComplexity int) int
	}

	Point struct {
		Latitude  func(childComplexity int) int
		Longitude func(childComplexity int) int
	}

	PointList struct {
		Points func(childComplexity int) int
	}

	Polygon struct {
		Coordinates func(childComplexity int) int
	}

	ProgrammingLanguage struct {
		ID func(childComplexity int) int
	}

	ProgrammingLanguageAggregateResult struct {
		Count func(childComplexity int) int
		IDMax func(childComplexity int) int
		IDMin func(childComplexity int) int
	}

	Query struct {
		AggregateLicense             func(childComplexity int, filter *model.LicenseFilter) int
		AggregatePackage             func(childComplexity int, filter *model.PackageFilter) int
		AggregatePackageType         func(childComplexity int, filter *model.PackageTypeFilter) int
		AggregatePackageVersion      func(childComplexity int, filter *model.PackageVersionFilter) int
		AggregateProgrammingLanguage func(childComplexity int, filter *model.ProgrammingLanguageFilter) int
		GetLicense                   func(childComplexity int, id string) int
		GetPackageType               func(childComplexity int, id string) int
		GetPackageVersion            func(childComplexity int, id string) int
		GetProgrammingLanguage       func(childComplexity int, id string) int
		QueryLicense                 func(childComplexity int, filter *model.LicenseFilter, order *model.LicenseOrder, first *int, offset *int) int
		QueryPackage                 func(childComplexity int, filter *model.PackageFilter, order *model.PackageOrder, first *int, offset *int) int
		QueryPackageType             func(childComplexity int, filter *model.PackageTypeFilter, order *model.PackageTypeOrder, first *int, offset *int) int
		QueryPackageVersion          func(childComplexity int, filter *model.PackageVersionFilter, order *model.PackageVersionOrder, first *int, offset *int) int
		QueryProgrammingLanguage     func(childComplexity int, filter *model.ProgrammingLanguageFilter, order *model.ProgrammingLanguageOrder, first *int, offset *int) int
	}

	UpdatePackagePayload struct {
		NumUids func(childComplexity int) int
		Package func(childComplexity int, filter *model.PackageFilter, order *model.PackageOrder, first *int, offset *int) int
	}
}

type MutationResolver interface {
	AddPackage(ctx context.Context, input []*model.AddPackageInput) (*model.AddPackagePayload, error)
	UpdatePackage(ctx context.Context, input model.UpdatePackageInput) (*model.UpdatePackagePayload, error)
	DeletePackage(ctx context.Context, filter model.PackageFilter) (*model.DeletePackagePayload, error)
	AddLicense(ctx context.Context, input []*model.AddLicenseInput, upsert *bool) (*model.AddLicensePayload, error)
	DeleteLicense(ctx context.Context, filter model.LicenseFilter) (*model.DeleteLicensePayload, error)
	AddPackageVersion(ctx context.Context, input []*model.AddPackageVersionInput, upsert *bool) (*model.AddPackageVersionPayload, error)
	DeletePackageVersion(ctx context.Context, filter model.PackageVersionFilter) (*model.DeletePackageVersionPayload, error)
	AddProgrammingLanguage(ctx context.Context, input []*model.AddProgrammingLanguageInput, upsert *bool) (*model.AddProgrammingLanguagePayload, error)
	DeleteProgrammingLanguage(ctx context.Context, filter model.ProgrammingLanguageFilter) (*model.DeleteProgrammingLanguagePayload, error)
	AddPackageType(ctx context.Context, input []*model.AddPackageTypeInput, upsert *bool) (*model.AddPackageTypePayload, error)
	DeletePackageType(ctx context.Context, filter model.PackageTypeFilter) (*model.DeletePackageTypePayload, error)
}
type QueryResolver interface {
	QueryPackage(ctx context.Context, filter *model.PackageFilter, order *model.PackageOrder, first *int, offset *int) ([]*model.Package, error)
	AggregatePackage(ctx context.Context, filter *model.PackageFilter) (*model.PackageAggregateResult, error)
	GetLicense(ctx context.Context, id string) (*model.License, error)
	QueryLicense(ctx context.Context, filter *model.LicenseFilter, order *model.LicenseOrder, first *int, offset *int) ([]*model.License, error)
	AggregateLicense(ctx context.Context, filter *model.LicenseFilter) (*model.LicenseAggregateResult, error)
	GetPackageVersion(ctx context.Context, id string) (*model.PackageVersion, error)
	QueryPackageVersion(ctx context.Context, filter *model.PackageVersionFilter, order *model.PackageVersionOrder, first *int, offset *int) ([]*model.PackageVersion, error)
	AggregatePackageVersion(ctx context.Context, filter *model.PackageVersionFilter) (*model.PackageVersionAggregateResult, error)
	GetProgrammingLanguage(ctx context.Context, id string) (*model.ProgrammingLanguage, error)
	QueryProgrammingLanguage(ctx context.Context, filter *model.ProgrammingLanguageFilter, order *model.ProgrammingLanguageOrder, first *int, offset *int) ([]*model.ProgrammingLanguage, error)
	AggregateProgrammingLanguage(ctx context.Context, filter *model.ProgrammingLanguageFilter) (*model.ProgrammingLanguageAggregateResult, error)
	GetPackageType(ctx context.Context, id string) (*model.PackageType, error)
	QueryPackageType(ctx context.Context, filter *model.PackageTypeFilter, order *model.PackageTypeOrder, first *int, offset *int) ([]*model.PackageType, error)
	AggregatePackageType(ctx context.Context, filter *model.PackageTypeFilter) (*model.PackageTypeAggregateResult, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AddLicensePayload.license":
		if e.complexity.AddLicensePayload.License == nil {
			break
		}

		args, err := ec.field_AddLicensePayload_license_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddLicensePayload.License(childComplexity, args["filter"].(*model.LicenseFilter), args["order"].(*model.LicenseOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddLicensePayload.numUids":
		if e.complexity.AddLicensePayload.NumUids == nil {
			break
		}

		return e.complexity.AddLicensePayload.NumUids(childComplexity), true

	case "AddPackagePayload.numUids":
		if e.complexity.AddPackagePayload.NumUids == nil {
			break
		}

		return e.complexity.AddPackagePayload.NumUids(childComplexity), true

	case "AddPackagePayload.package":
		if e.complexity.AddPackagePayload.Package == nil {
			break
		}

		args, err := ec.field_AddPackagePayload_package_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddPackagePayload.Package(childComplexity, args["filter"].(*model.PackageFilter), args["order"].(*model.PackageOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddPackageTypePayload.numUids":
		if e.complexity.AddPackageTypePayload.NumUids == nil {
			break
		}

		return e.complexity.AddPackageTypePayload.NumUids(childComplexity), true

	case "AddPackageTypePayload.packageType":
		if e.complexity.AddPackageTypePayload.PackageType == nil {
			break
		}

		args, err := ec.field_AddPackageTypePayload_packageType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddPackageTypePayload.PackageType(childComplexity, args["filter"].(*model.PackageTypeFilter), args["order"].(*model.PackageTypeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddPackageVersionPayload.numUids":
		if e.complexity.AddPackageVersionPayload.NumUids == nil {
			break
		}

		return e.complexity.AddPackageVersionPayload.NumUids(childComplexity), true

	case "AddPackageVersionPayload.packageVersion":
		if e.complexity.AddPackageVersionPayload.PackageVersion == nil {
			break
		}

		args, err := ec.field_AddPackageVersionPayload_packageVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddPackageVersionPayload.PackageVersion(childComplexity, args["filter"].(*model.PackageVersionFilter), args["order"].(*model.PackageVersionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddProgrammingLanguagePayload.numUids":
		if e.complexity.AddProgrammingLanguagePayload.NumUids == nil {
			break
		}

		return e.complexity.AddProgrammingLanguagePayload.NumUids(childComplexity), true

	case "AddProgrammingLanguagePayload.programmingLanguage":
		if e.complexity.AddProgrammingLanguagePayload.ProgrammingLanguage == nil {
			break
		}

		args, err := ec.field_AddProgrammingLanguagePayload_programmingLanguage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddProgrammingLanguagePayload.ProgrammingLanguage(childComplexity, args["filter"].(*model.ProgrammingLanguageFilter), args["order"].(*model.ProgrammingLanguageOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteLicensePayload.license":
		if e.complexity.DeleteLicensePayload.License == nil {
			break
		}

		args, err := ec.field_DeleteLicensePayload_license_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteLicensePayload.License(childComplexity, args["filter"].(*model.LicenseFilter), args["order"].(*model.LicenseOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteLicensePayload.msg":
		if e.complexity.DeleteLicensePayload.Msg == nil {
			break
		}

		return e.complexity.DeleteLicensePayload.Msg(childComplexity), true

	case "DeleteLicensePayload.numUids":
		if e.complexity.DeleteLicensePayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteLicensePayload.NumUids(childComplexity), true

	case "DeletePackagePayload.msg":
		if e.complexity.DeletePackagePayload.Msg == nil {
			break
		}

		return e.complexity.DeletePackagePayload.Msg(childComplexity), true

	case "DeletePackagePayload.numUids":
		if e.complexity.DeletePackagePayload.NumUids == nil {
			break
		}

		return e.complexity.DeletePackagePayload.NumUids(childComplexity), true

	case "DeletePackagePayload.package":
		if e.complexity.DeletePackagePayload.Package == nil {
			break
		}

		args, err := ec.field_DeletePackagePayload_package_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeletePackagePayload.Package(childComplexity, args["filter"].(*model.PackageFilter), args["order"].(*model.PackageOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeletePackageTypePayload.msg":
		if e.complexity.DeletePackageTypePayload.Msg == nil {
			break
		}

		return e.complexity.DeletePackageTypePayload.Msg(childComplexity), true

	case "DeletePackageTypePayload.numUids":
		if e.complexity.DeletePackageTypePayload.NumUids == nil {
			break
		}

		return e.complexity.DeletePackageTypePayload.NumUids(childComplexity), true

	case "DeletePackageTypePayload.packageType":
		if e.complexity.DeletePackageTypePayload.PackageType == nil {
			break
		}

		args, err := ec.field_DeletePackageTypePayload_packageType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeletePackageTypePayload.PackageType(childComplexity, args["filter"].(*model.PackageTypeFilter), args["order"].(*model.PackageTypeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeletePackageVersionPayload.msg":
		if e.complexity.DeletePackageVersionPayload.Msg == nil {
			break
		}

		return e.complexity.DeletePackageVersionPayload.Msg(childComplexity), true

	case "DeletePackageVersionPayload.numUids":
		if e.complexity.DeletePackageVersionPayload.NumUids == nil {
			break
		}

		return e.complexity.DeletePackageVersionPayload.NumUids(childComplexity), true

	case "DeletePackageVersionPayload.packageVersion":
		if e.complexity.DeletePackageVersionPayload.PackageVersion == nil {
			break
		}

		args, err := ec.field_DeletePackageVersionPayload_packageVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeletePackageVersionPayload.PackageVersion(childComplexity, args["filter"].(*model.PackageVersionFilter), args["order"].(*model.PackageVersionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteProgrammingLanguagePayload.msg":
		if e.complexity.DeleteProgrammingLanguagePayload.Msg == nil {
			break
		}

		return e.complexity.DeleteProgrammingLanguagePayload.Msg(childComplexity), true

	case "DeleteProgrammingLanguagePayload.numUids":
		if e.complexity.DeleteProgrammingLanguagePayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteProgrammingLanguagePayload.NumUids(childComplexity), true

	case "DeleteProgrammingLanguagePayload.programmingLanguage":
		if e.complexity.DeleteProgrammingLanguagePayload.ProgrammingLanguage == nil {
			break
		}

		args, err := ec.field_DeleteProgrammingLanguagePayload_programmingLanguage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteProgrammingLanguagePayload.ProgrammingLanguage(childComplexity, args["filter"].(*model.ProgrammingLanguageFilter), args["order"].(*model.ProgrammingLanguageOrder), args["first"].(*int), args["offset"].(*int)), true

	case "License.id":
		if e.complexity.License.ID == nil {
			break
		}

		return e.complexity.License.ID(childComplexity), true

	case "LicenseAggregateResult.count":
		if e.complexity.LicenseAggregateResult.Count == nil {
			break
		}

		return e.complexity.LicenseAggregateResult.Count(childComplexity), true

	case "LicenseAggregateResult.idMax":
		if e.complexity.LicenseAggregateResult.IDMax == nil {
			break
		}

		return e.complexity.LicenseAggregateResult.IDMax(childComplexity), true

	case "LicenseAggregateResult.idMin":
		if e.complexity.LicenseAggregateResult.IDMin == nil {
			break
		}

		return e.complexity.LicenseAggregateResult.IDMin(childComplexity), true

	case "MultiPolygon.polygons":
		if e.complexity.MultiPolygon.Polygons == nil {
			break
		}

		return e.complexity.MultiPolygon.Polygons(childComplexity), true

	case "Mutation.addLicense":
		if e.complexity.Mutation.AddLicense == nil {
			break
		}

		args, err := ec.field_Mutation_addLicense_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddLicense(childComplexity, args["input"].([]*model.AddLicenseInput), args["upsert"].(*bool)), true

	case "Mutation.addPackage":
		if e.complexity.Mutation.AddPackage == nil {
			break
		}

		args, err := ec.field_Mutation_addPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddPackage(childComplexity, args["input"].([]*model.AddPackageInput)), true

	case "Mutation.addPackageType":
		if e.complexity.Mutation.AddPackageType == nil {
			break
		}

		args, err := ec.field_Mutation_addPackageType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddPackageType(childComplexity, args["input"].([]*model.AddPackageTypeInput), args["upsert"].(*bool)), true

	case "Mutation.addPackageVersion":
		if e.complexity.Mutation.AddPackageVersion == nil {
			break
		}

		args, err := ec.field_Mutation_addPackageVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddPackageVersion(childComplexity, args["input"].([]*model.AddPackageVersionInput), args["upsert"].(*bool)), true

	case "Mutation.addProgrammingLanguage":
		if e.complexity.Mutation.AddProgrammingLanguage == nil {
			break
		}

		args, err := ec.field_Mutation_addProgrammingLanguage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProgrammingLanguage(childComplexity, args["input"].([]*model.AddProgrammingLanguageInput), args["upsert"].(*bool)), true

	case "Mutation.deleteLicense":
		if e.complexity.Mutation.DeleteLicense == nil {
			break
		}

		args, err := ec.field_Mutation_deleteLicense_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteLicense(childComplexity, args["filter"].(model.LicenseFilter)), true

	case "Mutation.deletePackage":
		if e.complexity.Mutation.DeletePackage == nil {
			break
		}

		args, err := ec.field_Mutation_deletePackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePackage(childComplexity, args["filter"].(model.PackageFilter)), true

	case "Mutation.deletePackageType":
		if e.complexity.Mutation.DeletePackageType == nil {
			break
		}

		args, err := ec.field_Mutation_deletePackageType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePackageType(childComplexity, args["filter"].(model.PackageTypeFilter)), true

	case "Mutation.deletePackageVersion":
		if e.complexity.Mutation.DeletePackageVersion == nil {
			break
		}

		args, err := ec.field_Mutation_deletePackageVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePackageVersion(childComplexity, args["filter"].(model.PackageVersionFilter)), true

	case "Mutation.deleteProgrammingLanguage":
		if e.complexity.Mutation.DeleteProgrammingLanguage == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProgrammingLanguage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProgrammingLanguage(childComplexity, args["filter"].(model.ProgrammingLanguageFilter)), true

	case "Mutation.updatePackage":
		if e.complexity.Mutation.UpdatePackage == nil {
			break
		}

		args, err := ec.field_Mutation_updatePackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePackage(childComplexity, args["input"].(model.UpdatePackageInput)), true

	case "Package.languages":
		if e.complexity.Package.Languages == nil {
			break
		}

		args, err := ec.field_Package_languages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Package.Languages(childComplexity, args["filter"].(*model.ProgrammingLanguageFilter), args["order"].(*model.ProgrammingLanguageOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Package.languagesAggregate":
		if e.complexity.Package.LanguagesAggregate == nil {
			break
		}

		args, err := ec.field_Package_languagesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Package.LanguagesAggregate(childComplexity, args["filter"].(*model.ProgrammingLanguageFilter)), true

	case "Package.licenses":
		if e.complexity.Package.Licenses == nil {
			break
		}

		args, err := ec.field_Package_licenses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Package.Licenses(childComplexity, args["filter"].(*model.LicenseFilter), args["order"].(*model.LicenseOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Package.licensesAggregate":
		if e.complexity.Package.LicensesAggregate == nil {
			break
		}

		args, err := ec.field_Package_licensesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Package.LicensesAggregate(childComplexity, args["filter"].(*model.LicenseFilter)), true

	case "Package.name":
		if e.complexity.Package.Name == nil {
			break
		}

		return e.complexity.Package.Name(childComplexity), true

	case "Package.type":
		if e.complexity.Package.Type == nil {
			break
		}

		args, err := ec.field_Package_type_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Package.Type(childComplexity, args["filter"].(*model.PackageTypeFilter)), true

	case "Package.url":
		if e.complexity.Package.URL == nil {
			break
		}

		return e.complexity.Package.URL(childComplexity), true

	case "Package.versions":
		if e.complexity.Package.Versions == nil {
			break
		}

		args, err := ec.field_Package_versions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Package.Versions(childComplexity, args["filter"].(*model.PackageVersionFilter), args["order"].(*model.PackageVersionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Package.versionsAggregate":
		if e.complexity.Package.VersionsAggregate == nil {
			break
		}

		args, err := ec.field_Package_versionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Package.VersionsAggregate(childComplexity, args["filter"].(*model.PackageVersionFilter)), true

	case "PackageAggregateResult.count":
		if e.complexity.PackageAggregateResult.Count == nil {
			break
		}

		return e.complexity.PackageAggregateResult.Count(childComplexity), true

	case "PackageAggregateResult.nameMax":
		if e.complexity.PackageAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.PackageAggregateResult.NameMax(childComplexity), true

	case "PackageAggregateResult.nameMin":
		if e.complexity.PackageAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.PackageAggregateResult.NameMin(childComplexity), true

	case "PackageAggregateResult.urlMax":
		if e.complexity.PackageAggregateResult.URLMax == nil {
			break
		}

		return e.complexity.PackageAggregateResult.URLMax(childComplexity), true

	case "PackageAggregateResult.urlMin":
		if e.complexity.PackageAggregateResult.URLMin == nil {
			break
		}

		return e.complexity.PackageAggregateResult.URLMin(childComplexity), true

	case "PackageType.id":
		if e.complexity.PackageType.ID == nil {
			break
		}

		return e.complexity.PackageType.ID(childComplexity), true

	case "PackageTypeAggregateResult.count":
		if e.complexity.PackageTypeAggregateResult.Count == nil {
			break
		}

		return e.complexity.PackageTypeAggregateResult.Count(childComplexity), true

	case "PackageTypeAggregateResult.idMax":
		if e.complexity.PackageTypeAggregateResult.IDMax == nil {
			break
		}

		return e.complexity.PackageTypeAggregateResult.IDMax(childComplexity), true

	case "PackageTypeAggregateResult.idMin":
		if e.complexity.PackageTypeAggregateResult.IDMin == nil {
			break
		}

		return e.complexity.PackageTypeAggregateResult.IDMin(childComplexity), true

	case "PackageVersion.id":
		if e.complexity.PackageVersion.ID == nil {
			break
		}

		return e.complexity.PackageVersion.ID(childComplexity), true

	case "PackageVersionAggregateResult.count":
		if e.complexity.PackageVersionAggregateResult.Count == nil {
			break
		}

		return e.complexity.PackageVersionAggregateResult.Count(childComplexity), true

	case "PackageVersionAggregateResult.idMax":
		if e.complexity.PackageVersionAggregateResult.IDMax == nil {
			break
		}

		return e.complexity.PackageVersionAggregateResult.IDMax(childComplexity), true

	case "PackageVersionAggregateResult.idMin":
		if e.complexity.PackageVersionAggregateResult.IDMin == nil {
			break
		}

		return e.complexity.PackageVersionAggregateResult.IDMin(childComplexity), true

	case "Point.latitude":
		if e.complexity.Point.Latitude == nil {
			break
		}

		return e.complexity.Point.Latitude(childComplexity), true

	case "Point.longitude":
		if e.complexity.Point.Longitude == nil {
			break
		}

		return e.complexity.Point.Longitude(childComplexity), true

	case "PointList.points":
		if e.complexity.PointList.Points == nil {
			break
		}

		return e.complexity.PointList.Points(childComplexity), true

	case "Polygon.coordinates":
		if e.complexity.Polygon.Coordinates == nil {
			break
		}

		return e.complexity.Polygon.Coordinates(childComplexity), true

	case "ProgrammingLanguage.id":
		if e.complexity.ProgrammingLanguage.ID == nil {
			break
		}

		return e.complexity.ProgrammingLanguage.ID(childComplexity), true

	case "ProgrammingLanguageAggregateResult.count":
		if e.complexity.ProgrammingLanguageAggregateResult.Count == nil {
			break
		}

		return e.complexity.ProgrammingLanguageAggregateResult.Count(childComplexity), true

	case "ProgrammingLanguageAggregateResult.idMax":
		if e.complexity.ProgrammingLanguageAggregateResult.IDMax == nil {
			break
		}

		return e.complexity.ProgrammingLanguageAggregateResult.IDMax(childComplexity), true

	case "ProgrammingLanguageAggregateResult.idMin":
		if e.complexity.ProgrammingLanguageAggregateResult.IDMin == nil {
			break
		}

		return e.complexity.ProgrammingLanguageAggregateResult.IDMin(childComplexity), true

	case "Query.aggregateLicense":
		if e.complexity.Query.AggregateLicense == nil {
			break
		}

		args, err := ec.field_Query_aggregateLicense_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateLicense(childComplexity, args["filter"].(*model.LicenseFilter)), true

	case "Query.aggregatePackage":
		if e.complexity.Query.AggregatePackage == nil {
			break
		}

		args, err := ec.field_Query_aggregatePackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregatePackage(childComplexity, args["filter"].(*model.PackageFilter)), true

	case "Query.aggregatePackageType":
		if e.complexity.Query.AggregatePackageType == nil {
			break
		}

		args, err := ec.field_Query_aggregatePackageType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregatePackageType(childComplexity, args["filter"].(*model.PackageTypeFilter)), true

	case "Query.aggregatePackageVersion":
		if e.complexity.Query.AggregatePackageVersion == nil {
			break
		}

		args, err := ec.field_Query_aggregatePackageVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregatePackageVersion(childComplexity, args["filter"].(*model.PackageVersionFilter)), true

	case "Query.aggregateProgrammingLanguage":
		if e.complexity.Query.AggregateProgrammingLanguage == nil {
			break
		}

		args, err := ec.field_Query_aggregateProgrammingLanguage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateProgrammingLanguage(childComplexity, args["filter"].(*model.ProgrammingLanguageFilter)), true

	case "Query.getLicense":
		if e.complexity.Query.GetLicense == nil {
			break
		}

		args, err := ec.field_Query_getLicense_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetLicense(childComplexity, args["id"].(string)), true

	case "Query.getPackageType":
		if e.complexity.Query.GetPackageType == nil {
			break
		}

		args, err := ec.field_Query_getPackageType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPackageType(childComplexity, args["id"].(string)), true

	case "Query.getPackageVersion":
		if e.complexity.Query.GetPackageVersion == nil {
			break
		}

		args, err := ec.field_Query_getPackageVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPackageVersion(childComplexity, args["id"].(string)), true

	case "Query.getProgrammingLanguage":
		if e.complexity.Query.GetProgrammingLanguage == nil {
			break
		}

		args, err := ec.field_Query_getProgrammingLanguage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetProgrammingLanguage(childComplexity, args["id"].(string)), true

	case "Query.queryLicense":
		if e.complexity.Query.QueryLicense == nil {
			break
		}

		args, err := ec.field_Query_queryLicense_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryLicense(childComplexity, args["filter"].(*model.LicenseFilter), args["order"].(*model.LicenseOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryPackage":
		if e.complexity.Query.QueryPackage == nil {
			break
		}

		args, err := ec.field_Query_queryPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryPackage(childComplexity, args["filter"].(*model.PackageFilter), args["order"].(*model.PackageOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryPackageType":
		if e.complexity.Query.QueryPackageType == nil {
			break
		}

		args, err := ec.field_Query_queryPackageType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryPackageType(childComplexity, args["filter"].(*model.PackageTypeFilter), args["order"].(*model.PackageTypeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryPackageVersion":
		if e.complexity.Query.QueryPackageVersion == nil {
			break
		}

		args, err := ec.field_Query_queryPackageVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryPackageVersion(childComplexity, args["filter"].(*model.PackageVersionFilter), args["order"].(*model.PackageVersionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryProgrammingLanguage":
		if e.complexity.Query.QueryProgrammingLanguage == nil {
			break
		}

		args, err := ec.field_Query_queryProgrammingLanguage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryProgrammingLanguage(childComplexity, args["filter"].(*model.ProgrammingLanguageFilter), args["order"].(*model.ProgrammingLanguageOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdatePackagePayload.numUids":
		if e.complexity.UpdatePackagePayload.NumUids == nil {
			break
		}

		return e.complexity.UpdatePackagePayload.NumUids(childComplexity), true

	case "UpdatePackagePayload.package":
		if e.complexity.UpdatePackagePayload.Package == nil {
			break
		}

		args, err := ec.field_UpdatePackagePayload_package_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdatePackagePayload.Package(childComplexity, args["filter"].(*model.PackageFilter), args["order"].(*model.PackageOrder), args["first"].(*int), args["offset"].(*int)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._queryMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error) {
				return ec._Query(ctx, rc.Operation.SelectionSet), nil
			})
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "schema.graphqls", Input: `#######################
# Input Schema
#######################

directive @goTag(
	key: String!
	value: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

type Package {
	name: String! @search @goTag(key: "json", value: "Package.name")
	versions(filter: PackageVersionFilter, order: PackageVersionOrder, first: Int, offset: Int): [PackageVersion]!  @goTag(key: "json", value: "Package.versions")
	licenses(filter: LicenseFilter, order: LicenseOrder, first: Int, offset: Int): [License] @goTag(key: "json", value: "Package.licenses")
	languages(filter: ProgrammingLanguageFilter, order: ProgrammingLanguageOrder, first: Int, offset: Int): [ProgrammingLanguage] @goTag(key: "json", value: "Package.languages")
	type(filter: PackageTypeFilter): PackageType! @goTag(key: "json", value: "Package.type")
	url: String @search @goTag(key: "json", value: "Package.url")
	versionsAggregate(filter: PackageVersionFilter): PackageVersionAggregateResult
	licensesAggregate(filter: LicenseFilter): LicenseAggregateResult
	languagesAggregate(filter: ProgrammingLanguageFilter): ProgrammingLanguageAggregateResult
}

type License {
	id: String! @id @goTag(key: "json", value: "License.id")
}

type PackageVersion {
	id: String! @id @goTag(key: "json", value: "PackageVersion.id")
}

type ProgrammingLanguage {
	id: String! @id @goTag(key: "json", value: "ProgrammingLanguage.id")
}

type PackageType {
	id: String! @id @goTag(key: "json", value: "PackageType.id")
}

#######################
# Extended Definitions
#######################

"""
The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

"""
The DateTime scalar type represents date and time as a string in RFC3339 format.
For example: "1985-04-12T23:20:50.52Z" represents 20 minutes and 50.52 seconds after the 23rd hour of April 12th, 1985 in UTC.
"""
scalar DateTime

input IntRange{
	min: Int!
	max: Int!
}

input FloatRange{
	min: Float!
	max: Float!
}

input Int64Range{
	min: Int64!
	max: Int64!
}

input DateTimeRange{
	min: DateTime!
	max: DateTime!
}

input StringRange{
	min: String!
	max: String!
}

enum DgraphIndex {
	int
	int64
	float
	bool
	hash
	exact
	term
	fulltext
	trigram
	regexp
	year
	month
	day
	hour
	geo
}

input AuthRule {
	and: [AuthRule]
	or: [AuthRule]
	not: AuthRule
	rule: String
}

enum HTTPMethod {
	GET
	POST
	PUT
	PATCH
	DELETE
}

enum Mode {
	BATCH
	SINGLE
}

input CustomHTTP {
	url: String!
	method: HTTPMethod!
	body: String
	graphql: String
	mode: Mode
	forwardHeaders: [String!]
	secretHeaders: [String!]
	introspectionHeaders: [String!]
	skipIntrospection: Boolean
}

type Point {
	longitude: Float!
	latitude: Float!
}

input PointRef {
	longitude: Float!
	latitude: Float!
}

input NearFilter {
	distance: Float!
	coordinate: PointRef!
}

input PointGeoFilter {
	near: NearFilter
	within: WithinFilter
}

type PointList {
	points: [Point!]!
}

input PointListRef {
	points: [PointRef!]!
}

type Polygon {
	coordinates: [PointList!]!
}

input PolygonRef {
	coordinates: [PointListRef!]!
}

type MultiPolygon {
	polygons: [Polygon!]!
}

input MultiPolygonRef {
	polygons: [PolygonRef!]!
}

input WithinFilter {
	polygon: PolygonRef!
}

input ContainsFilter {
	point: PointRef
	polygon: PolygonRef
}

input IntersectsFilter {
	polygon: PolygonRef
	multiPolygon: MultiPolygonRef
}

input PolygonGeoFilter {
	near: NearFilter
	within: WithinFilter
	contains: ContainsFilter
	intersects: IntersectsFilter
}

input GenerateQueryParams {
	get: Boolean
	query: Boolean
	password: Boolean
	aggregate: Boolean
}

input GenerateMutationParams {
	add: Boolean
	update: Boolean
	delete: Boolean
}

directive @hasInverse(field: String!) on FIELD_DEFINITION
directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION
directive @dgraph(type: String, pred: String) on OBJECT | INTERFACE | FIELD_DEFINITION
directive @id on FIELD_DEFINITION
directive @withSubscription on OBJECT | INTERFACE | FIELD_DEFINITION
directive @secret(field: String!, pred: String) on OBJECT | INTERFACE
directive @auth(
	password: AuthRule
	query: AuthRule,
	add: AuthRule,
	update: AuthRule,
	delete: AuthRule) on OBJECT | INTERFACE
directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION
directive @remote on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM
directive @remoteResponse(name: String) on FIELD_DEFINITION
directive @cascade(fields: [String]) on FIELD
directive @lambda on FIELD_DEFINITION
directive @lambdaOnMutate(add: Boolean, update: Boolean, delete: Boolean) on OBJECT | INTERFACE
directive @cacheControl(maxAge: Int!) on QUERY
directive @generate(
	query: GenerateQueryParams,
	mutation: GenerateMutationParams,
	subscription: Boolean) on OBJECT | INTERFACE

input IntFilter {
	eq: Int
	in: [Int]
	le: Int
	lt: Int
	ge: Int
	gt: Int
	between: IntRange
}

input Int64Filter {
	eq: Int64
	in: [Int64]
	le: Int64
	lt: Int64
	ge: Int64
	gt: Int64
	between: Int64Range
}

input FloatFilter {
	eq: Float
	in: [Float]
	le: Float
	lt: Float
	ge: Float
	gt: Float
	between: FloatRange
}

input DateTimeFilter {
	eq: DateTime
	in: [DateTime]
	le: DateTime
	lt: DateTime
	ge: DateTime
	gt: DateTime
	between: DateTimeRange
}

input StringTermFilter {
	allofterms: String
	anyofterms: String
}

input StringRegExpFilter {
	regexp: String
}

input StringFullTextFilter {
	alloftext: String
	anyoftext: String
}

input StringExactFilter {
	eq: String
	in: [String]
	le: String
	lt: String
	ge: String
	gt: String
	between: StringRange
}

input StringHashFilter {
	eq: String
	in: [String]
}

#######################
# Generated Types
#######################

type AddLicensePayload {
	license(filter: LicenseFilter, order: LicenseOrder, first: Int, offset: Int): [License]
	numUids: Int
}

type AddPackagePayload {
	package(filter: PackageFilter, order: PackageOrder, first: Int, offset: Int): [Package]
	numUids: Int
}

type AddPackageTypePayload {
	packageType(filter: PackageTypeFilter, order: PackageTypeOrder, first: Int, offset: Int): [PackageType]
	numUids: Int
}

type AddPackageVersionPayload {
	packageVersion(filter: PackageVersionFilter, order: PackageVersionOrder, first: Int, offset: Int): [PackageVersion]
	numUids: Int
}

type AddProgrammingLanguagePayload {
	programmingLanguage(filter: ProgrammingLanguageFilter, order: ProgrammingLanguageOrder, first: Int, offset: Int): [ProgrammingLanguage]
	numUids: Int
}

type DeleteLicensePayload {
	license(filter: LicenseFilter, order: LicenseOrder, first: Int, offset: Int): [License]
	msg: String
	numUids: Int
}

type DeletePackagePayload {
	package(filter: PackageFilter, order: PackageOrder, first: Int, offset: Int): [Package]
	msg: String
	numUids: Int
}

type DeletePackageTypePayload {
	packageType(filter: PackageTypeFilter, order: PackageTypeOrder, first: Int, offset: Int): [PackageType]
	msg: String
	numUids: Int
}

type DeletePackageVersionPayload {
	packageVersion(filter: PackageVersionFilter, order: PackageVersionOrder, first: Int, offset: Int): [PackageVersion]
	msg: String
	numUids: Int
}

type DeleteProgrammingLanguagePayload {
	programmingLanguage(filter: ProgrammingLanguageFilter, order: ProgrammingLanguageOrder, first: Int, offset: Int): [ProgrammingLanguage]
	msg: String
	numUids: Int
}

type LicenseAggregateResult {
	count: Int
	idMin: String
	idMax: String
}

type PackageAggregateResult {
	count: Int
	nameMin: String
	nameMax: String
	urlMin: String
	urlMax: String
}

type PackageTypeAggregateResult {
	count: Int
	idMin: String
	idMax: String
}

type PackageVersionAggregateResult {
	count: Int
	idMin: String
	idMax: String
}

type ProgrammingLanguageAggregateResult {
	count: Int
	idMin: String
	idMax: String
}

type UpdatePackagePayload {
	package(filter: PackageFilter, order: PackageOrder, first: Int, offset: Int): [Package]
	numUids: Int
}

#######################
# Generated Enums
#######################

enum LicenseHasFilter {
	id
}

enum LicenseOrderable {
	id
}

enum PackageHasFilter {
	name
	versions
	licenses
	languages
	type
	url
}

enum PackageOrderable {
	name
	url
}

enum PackageTypeHasFilter {
	id
}

enum PackageTypeOrderable {
	id
}

enum PackageVersionHasFilter {
	id
}

enum PackageVersionOrderable {
	id
}

enum ProgrammingLanguageHasFilter {
	id
}

enum ProgrammingLanguageOrderable {
	id
}

#######################
# Generated Inputs
#######################

input AddLicenseInput {
	id: String! @goTag(key: "json", value: "License.id")
}

input AddPackageInput {
	name: String! @goTag(key: "json", value: "Package.name")
	versions: [PackageVersionRef]! @goTag(key: "json", value: "Package.versions")
	licenses: [LicenseRef] @goTag(key: "json", value: "Package.licenses")
	languages: [ProgrammingLanguageRef] @goTag(key: "json", value: "Package.languages")
	type: PackageTypeRef! @goTag(key: "json", value: "Package.type")
	url: String @goTag(key: "json", value: "Package.url")
}

input AddPackageTypeInput {
	id: String!  @goTag(key: "json", value: "PackageType.id")
}

input AddPackageVersionInput {
	id: String!  @goTag(key: "json", value: "PackageVersion.id")
}

input AddProgrammingLanguageInput {
	id: String!  @goTag(key: "json", value: "ProgrammingLanguage.id")
}

input LicenseFilter {
	id: StringHashFilter
	has: [LicenseHasFilter]
	and: [LicenseFilter]
	or: [LicenseFilter]
	not: LicenseFilter
}

input LicenseOrder {
	asc: LicenseOrderable
	desc: LicenseOrderable
	then: LicenseOrder
}

input LicenseRef {
	id: String! @goTag(key: "json", value: "License.id")
}

input PackageFilter {
	name: StringTermFilter
	url: StringTermFilter
	has: [PackageHasFilter]
	and: [PackageFilter]
	or: [PackageFilter]
	not: PackageFilter
}

input PackageOrder {
	asc: PackageOrderable
	desc: PackageOrderable
	then: PackageOrder
}

input PackagePatch {
	name: String @goTag(key: "json", value: "Package.name")
	versions: [PackageVersionRef] @goTag(key: "json", value: "Package.versions")
	licenses: [LicenseRef] @goTag(key: "json", value: "Package.licenses")
	languages: [ProgrammingLanguageRef] @goTag(key: "json", value: "Package.languages")
	type: PackageTypeRef @goTag(key: "json", value: "Package.type")
	url: String @goTag(key: "json", value: "Package.url")
}

input PackageRef {
	name: String @goTag(key: "json", value: "Package.name")
	versions: [PackageVersionRef] @goTag(key: "json", value: "Package.versions")
	licenses: [LicenseRef] @goTag(key: "json", value: "Package.licenses")
	languages: [ProgrammingLanguageRef] @goTag(key: "json", value: "Package.languages")
	type: PackageTypeRef @goTag(key: "json", value: "Package.type")
	url: String @goTag(key: "json", value: "Package.url")
}

input PackageTypeFilter {
	id: StringHashFilter
	has: [PackageTypeHasFilter]
	and: [PackageTypeFilter]
	or: [PackageTypeFilter]
	not: PackageTypeFilter
}

input PackageTypeOrder {
	asc: PackageTypeOrderable
	desc: PackageTypeOrderable
	then: PackageTypeOrder
}

input PackageTypeRef {
	id: String! @goTag(key: "json", value: "PackageType.id")
}

input PackageVersionFilter {
	id: StringHashFilter
	has: [PackageVersionHasFilter]
	and: [PackageVersionFilter]
	or: [PackageVersionFilter]
	not: PackageVersionFilter
}

input PackageVersionOrder {
	asc: PackageVersionOrderable
	desc: PackageVersionOrderable
	then: PackageVersionOrder
}

input PackageVersionRef {
	id: String! @goTag(key: "json", value: "PackageVersion.id")
}

input ProgrammingLanguageFilter {
	id: StringHashFilter
	has: [ProgrammingLanguageHasFilter]
	and: [ProgrammingLanguageFilter]
	or: [ProgrammingLanguageFilter]
	not: ProgrammingLanguageFilter
}

input ProgrammingLanguageOrder {
	asc: ProgrammingLanguageOrderable
	desc: ProgrammingLanguageOrderable
	then: ProgrammingLanguageOrder
}

input ProgrammingLanguageRef {
	id: String! @goTag(key: "json", value: "ProgrammingLanguage.id")
}

input UpdatePackageInput {
	filter: PackageFilter!
	set: PackagePatch
	remove: PackagePatch
}

#######################
# Generated Query
#######################

type Query {
	queryPackage(filter: PackageFilter, order: PackageOrder, first: Int, offset: Int): [Package]
	aggregatePackage(filter: PackageFilter): PackageAggregateResult
	getLicense(id: String!): License
	queryLicense(filter: LicenseFilter, order: LicenseOrder, first: Int, offset: Int): [License]
	aggregateLicense(filter: LicenseFilter): LicenseAggregateResult
	getPackageVersion(id: String!): PackageVersion
	queryPackageVersion(filter: PackageVersionFilter, order: PackageVersionOrder, first: Int, offset: Int): [PackageVersion]
	aggregatePackageVersion(filter: PackageVersionFilter): PackageVersionAggregateResult
	getProgrammingLanguage(id: String!): ProgrammingLanguage
	queryProgrammingLanguage(filter: ProgrammingLanguageFilter, order: ProgrammingLanguageOrder, first: Int, offset: Int): [ProgrammingLanguage]
	aggregateProgrammingLanguage(filter: ProgrammingLanguageFilter): ProgrammingLanguageAggregateResult
	getPackageType(id: String!): PackageType
	queryPackageType(filter: PackageTypeFilter, order: PackageTypeOrder, first: Int, offset: Int): [PackageType]
	aggregatePackageType(filter: PackageTypeFilter): PackageTypeAggregateResult
}

#######################
# Generated Mutations
#######################

type Mutation {
	addPackage(input: [AddPackageInput!]!): AddPackagePayload
	updatePackage(input: UpdatePackageInput!): UpdatePackagePayload
	deletePackage(filter: PackageFilter!): DeletePackagePayload
	addLicense(input: [AddLicenseInput!]!, upsert: Boolean): AddLicensePayload
	deleteLicense(filter: LicenseFilter!): DeleteLicensePayload
	addPackageVersion(input: [AddPackageVersionInput!]!, upsert: Boolean): AddPackageVersionPayload
	deletePackageVersion(filter: PackageVersionFilter!): DeletePackageVersionPayload
	addProgrammingLanguage(input: [AddProgrammingLanguageInput!]!, upsert: Boolean): AddProgrammingLanguagePayload
	deleteProgrammingLanguage(filter: ProgrammingLanguageFilter!): DeleteProgrammingLanguagePayload
	addPackageType(input: [AddPackageTypeInput!]!, upsert: Boolean): AddPackageTypePayload
	deletePackageType(filter: PackageTypeFilter!): DeletePackageTypePayload
}

`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_auth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.AuthRule
	if tmp, ok := rawArgs["password"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
		arg0, err = ec.unmarshalOAuthRule2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAuthRule(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["password"] = arg0
	var arg1 *model.AuthRule
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg1, err = ec.unmarshalOAuthRule2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAuthRule(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg1
	var arg2 *model.AuthRule
	if tmp, ok := rawArgs["add"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("add"))
		arg2, err = ec.unmarshalOAuthRule2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAuthRule(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["add"] = arg2
	var arg3 *model.AuthRule
	if tmp, ok := rawArgs["update"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("update"))
		arg3, err = ec.unmarshalOAuthRule2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAuthRule(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["update"] = arg3
	var arg4 *model.AuthRule
	if tmp, ok := rawArgs["delete"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("delete"))
		arg4, err = ec.unmarshalOAuthRule2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAuthRule(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["delete"] = arg4
	return args, nil
}

func (ec *executionContext) dir_cacheControl_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["maxAge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxAge"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["maxAge"] = arg0
	return args, nil
}

func (ec *executionContext) dir_cascade_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*string
	if tmp, ok := rawArgs["fields"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fields"))
		arg0, err = ec.unmarshalOString2ᚕᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fields"] = arg0
	return args, nil
}

func (ec *executionContext) dir_custom_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.CustomHTTP
	if tmp, ok := rawArgs["http"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("http"))
		arg0, err = ec.unmarshalOCustomHTTP2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐCustomHTTP(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["http"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["dql"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dql"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dql"] = arg1
	return args, nil
}

func (ec *executionContext) dir_dgraph_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["type"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["type"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["pred"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pred"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pred"] = arg1
	return args, nil
}

func (ec *executionContext) dir_generate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.GenerateQueryParams
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalOGenerateQueryParams2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐGenerateQueryParams(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	var arg1 *model.GenerateMutationParams
	if tmp, ok := rawArgs["mutation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mutation"))
		arg1, err = ec.unmarshalOGenerateMutationParams2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐGenerateMutationParams(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mutation"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["subscription"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscription"))
		arg2, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subscription"] = arg2
	return args, nil
}

func (ec *executionContext) dir_goTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["value"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["value"] = arg1
	return args, nil
}

func (ec *executionContext) dir_hasInverse_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	return args, nil
}

func (ec *executionContext) dir_lambdaOnMutate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["add"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("add"))
		arg0, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["add"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["update"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("update"))
		arg1, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["update"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["delete"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("delete"))
		arg2, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["delete"] = arg2
	return args, nil
}

func (ec *executionContext) dir_remoteResponse_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) dir_search_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.DgraphIndex
	if tmp, ok := rawArgs["by"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("by"))
		arg0, err = ec.unmarshalODgraphIndex2ᚕgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDgraphIndexᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["by"] = arg0
	return args, nil
}

func (ec *executionContext) dir_secret_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["pred"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pred"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pred"] = arg1
	return args, nil
}

func (ec *executionContext) field_AddLicensePayload_license_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.LicenseFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLicenseFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.LicenseOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOLicenseOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_AddPackagePayload_package_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PackageOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOPackageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_AddPackageTypePayload_packageType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageTypeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageTypeFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PackageTypeOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOPackageTypeOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_AddPackageVersionPayload_packageVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageVersionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageVersionFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PackageVersionOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOPackageVersionOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_AddProgrammingLanguagePayload_programmingLanguage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ProgrammingLanguageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOProgrammingLanguageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.ProgrammingLanguageOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOProgrammingLanguageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_DeleteLicensePayload_license_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.LicenseFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLicenseFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.LicenseOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOLicenseOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_DeletePackagePayload_package_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PackageOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOPackageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_DeletePackageTypePayload_packageType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageTypeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageTypeFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PackageTypeOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOPackageTypeOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_DeletePackageVersionPayload_packageVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageVersionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageVersionFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PackageVersionOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOPackageVersionOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_DeleteProgrammingLanguagePayload_programmingLanguage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ProgrammingLanguageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOProgrammingLanguageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.ProgrammingLanguageOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOProgrammingLanguageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_addLicense_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*model.AddLicenseInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddLicenseInput2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddLicenseInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["upsert"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("upsert"))
		arg1, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upsert"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addPackageType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*model.AddPackageTypeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddPackageTypeInput2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageTypeInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["upsert"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("upsert"))
		arg1, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upsert"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addPackageVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*model.AddPackageVersionInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddPackageVersionInput2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageVersionInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["upsert"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("upsert"))
		arg1, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upsert"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addPackage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*model.AddPackageInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddPackageInput2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_addProgrammingLanguage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*model.AddProgrammingLanguageInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddProgrammingLanguageInput2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddProgrammingLanguageInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["upsert"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("upsert"))
		arg1, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upsert"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteLicense_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.LicenseFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNLicenseFilter2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deletePackageType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PackageTypeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNPackageTypeFilter2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deletePackageVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PackageVersionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNPackageVersionFilter2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deletePackage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PackageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNPackageFilter2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteProgrammingLanguage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ProgrammingLanguageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNProgrammingLanguageFilter2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePackage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdatePackageInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdatePackageInput2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐUpdatePackageInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Package_languagesAggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ProgrammingLanguageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOProgrammingLanguageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Package_languages_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ProgrammingLanguageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOProgrammingLanguageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.ProgrammingLanguageOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOProgrammingLanguageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_Package_licensesAggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.LicenseFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLicenseFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Package_licenses_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.LicenseFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLicenseFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.LicenseOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOLicenseOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_Package_type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageTypeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageTypeFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Package_versionsAggregate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageVersionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageVersionFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Package_versions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageVersionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageVersionFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PackageVersionOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOPackageVersionOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_aggregateLicense_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.LicenseFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLicenseFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_aggregatePackageType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageTypeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageTypeFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_aggregatePackageVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageVersionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageVersionFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_aggregatePackage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_aggregateProgrammingLanguage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ProgrammingLanguageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOProgrammingLanguageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getLicense_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getPackageType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getPackageVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getProgrammingLanguage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_queryLicense_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.LicenseFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLicenseFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.LicenseOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOLicenseOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_queryPackageType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageTypeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageTypeFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PackageTypeOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOPackageTypeOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_queryPackageVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageVersionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageVersionFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PackageVersionOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOPackageVersionOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_queryPackage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PackageOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOPackageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_queryProgrammingLanguage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ProgrammingLanguageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOProgrammingLanguageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.ProgrammingLanguageOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOProgrammingLanguageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_UpdatePackagePayload_package_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PackageFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPackageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PackageOrder
	if tmp, ok := rawArgs["order"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
		arg1, err = ec.unmarshalOPackageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["order"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

func (ec *executionContext) _queryMiddleware(ctx context.Context, obj *ast.OperationDefinition, next func(ctx context.Context) (interface{}, error)) graphql.Marshaler {

	for _, d := range obj.Directives {
		switch d.Name {
		case "cacheControl":
			rawArgs := d.ArgumentMap(ec.Variables)
			args, err := ec.dir_cacheControl_args(ctx, rawArgs)
			if err != nil {
				ec.Error(ctx, err)
				return graphql.Null
			}
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.CacheControl == nil {
					return nil, errors.New("directive cacheControl is not implemented")
				}
				return ec.directives.CacheControl(ctx, obj, n, args["maxAge"].(int))
			}
		}
	}
	tmp, err := next(ctx)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if data, ok := tmp.(graphql.Marshaler); ok {
		return data
	}
	ec.Errorf(ctx, `unexpected type %T from directive, should be graphql.Marshaler`, tmp)
	return graphql.Null

}

func (ec *executionContext) _fieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) interface{} {
	fc := graphql.GetFieldContext(ctx)
	for _, d := range fc.Field.Directives {
		switch d.Name {
		case "cascade":
			rawArgs := d.ArgumentMap(ec.Variables)
			args, err := ec.dir_cascade_args(ctx, rawArgs)
			if err != nil {
				ec.Error(ctx, err)
				return nil
			}
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.Cascade == nil {
					return nil, errors.New("directive cascade is not implemented")
				}
				return ec.directives.Cascade(ctx, obj, n, args["fields"].([]*string))
			}
		}
	}
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AddLicensePayload_license(ctx context.Context, field graphql.CollectedField, obj *model.AddLicensePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AddLicensePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AddLicensePayload_license_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.License, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.License)
	fc.Result = res
	return ec.marshalOLicense2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicense(ctx, field.Selections, res)
}

func (ec *executionContext) _AddLicensePayload_numUids(ctx context.Context, field graphql.CollectedField, obj *model.AddLicensePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AddLicensePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUids, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _AddPackagePayload_package(ctx context.Context, field graphql.CollectedField, obj *model.AddPackagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AddPackagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AddPackagePayload_package_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Package)
	fc.Result = res
	return ec.marshalOPackage2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _AddPackagePayload_numUids(ctx context.Context, field graphql.CollectedField, obj *model.AddPackagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AddPackagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUids, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _AddPackageTypePayload_packageType(ctx context.Context, field graphql.CollectedField, obj *model.AddPackageTypePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AddPackageTypePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AddPackageTypePayload_packageType_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageType, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PackageType)
	fc.Result = res
	return ec.marshalOPackageType2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageType(ctx, field.Selections, res)
}

func (ec *executionContext) _AddPackageTypePayload_numUids(ctx context.Context, field graphql.CollectedField, obj *model.AddPackageTypePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AddPackageTypePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUids, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _AddPackageVersionPayload_packageVersion(ctx context.Context, field graphql.CollectedField, obj *model.AddPackageVersionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AddPackageVersionPayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AddPackageVersionPayload_packageVersion_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageVersion, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PackageVersion)
	fc.Result = res
	return ec.marshalOPackageVersion2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _AddPackageVersionPayload_numUids(ctx context.Context, field graphql.CollectedField, obj *model.AddPackageVersionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AddPackageVersionPayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUids, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _AddProgrammingLanguagePayload_programmingLanguage(ctx context.Context, field graphql.CollectedField, obj *model.AddProgrammingLanguagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AddProgrammingLanguagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_AddProgrammingLanguagePayload_programmingLanguage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProgrammingLanguage, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ProgrammingLanguage)
	fc.Result = res
	return ec.marshalOProgrammingLanguage2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) _AddProgrammingLanguagePayload_numUids(ctx context.Context, field graphql.CollectedField, obj *model.AddProgrammingLanguagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AddProgrammingLanguagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUids, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _DeleteLicensePayload_license(ctx context.Context, field graphql.CollectedField, obj *model.DeleteLicensePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeleteLicensePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_DeleteLicensePayload_license_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.License, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.License)
	fc.Result = res
	return ec.marshalOLicense2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicense(ctx, field.Selections, res)
}

func (ec *executionContext) _DeleteLicensePayload_msg(ctx context.Context, field graphql.CollectedField, obj *model.DeleteLicensePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeleteLicensePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Msg, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DeleteLicensePayload_numUids(ctx context.Context, field graphql.CollectedField, obj *model.DeleteLicensePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeleteLicensePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUids, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _DeletePackagePayload_package(ctx context.Context, field graphql.CollectedField, obj *model.DeletePackagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeletePackagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_DeletePackagePayload_package_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Package)
	fc.Result = res
	return ec.marshalOPackage2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _DeletePackagePayload_msg(ctx context.Context, field graphql.CollectedField, obj *model.DeletePackagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeletePackagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Msg, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DeletePackagePayload_numUids(ctx context.Context, field graphql.CollectedField, obj *model.DeletePackagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeletePackagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUids, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _DeletePackageTypePayload_packageType(ctx context.Context, field graphql.CollectedField, obj *model.DeletePackageTypePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeletePackageTypePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_DeletePackageTypePayload_packageType_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageType, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PackageType)
	fc.Result = res
	return ec.marshalOPackageType2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageType(ctx, field.Selections, res)
}

func (ec *executionContext) _DeletePackageTypePayload_msg(ctx context.Context, field graphql.CollectedField, obj *model.DeletePackageTypePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeletePackageTypePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Msg, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DeletePackageTypePayload_numUids(ctx context.Context, field graphql.CollectedField, obj *model.DeletePackageTypePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeletePackageTypePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUids, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _DeletePackageVersionPayload_packageVersion(ctx context.Context, field graphql.CollectedField, obj *model.DeletePackageVersionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeletePackageVersionPayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_DeletePackageVersionPayload_packageVersion_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageVersion, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PackageVersion)
	fc.Result = res
	return ec.marshalOPackageVersion2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _DeletePackageVersionPayload_msg(ctx context.Context, field graphql.CollectedField, obj *model.DeletePackageVersionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeletePackageVersionPayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Msg, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DeletePackageVersionPayload_numUids(ctx context.Context, field graphql.CollectedField, obj *model.DeletePackageVersionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeletePackageVersionPayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUids, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _DeleteProgrammingLanguagePayload_programmingLanguage(ctx context.Context, field graphql.CollectedField, obj *model.DeleteProgrammingLanguagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeleteProgrammingLanguagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_DeleteProgrammingLanguagePayload_programmingLanguage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProgrammingLanguage, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ProgrammingLanguage)
	fc.Result = res
	return ec.marshalOProgrammingLanguage2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) _DeleteProgrammingLanguagePayload_msg(ctx context.Context, field graphql.CollectedField, obj *model.DeleteProgrammingLanguagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeleteProgrammingLanguagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Msg, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DeleteProgrammingLanguagePayload_numUids(ctx context.Context, field graphql.CollectedField, obj *model.DeleteProgrammingLanguagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "DeleteProgrammingLanguagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUids, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _License_id(ctx context.Context, field graphql.CollectedField, obj *model.License) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "License",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Id == nil {
				return nil, errors.New("directive id is not implemented")
			}
			return ec.directives.Id(ctx, obj, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			key, err := ec.unmarshalNString2string(ctx, "json")
			if err != nil {
				return nil, err
			}
			value, err := ec.unmarshalOString2ᚖstring(ctx, "License.id")
			if err != nil {
				return nil, err
			}
			if ec.directives.GoTag == nil {
				return nil, errors.New("directive goTag is not implemented")
			}
			return ec.directives.GoTag(ctx, obj, directive1, key, value)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _LicenseAggregateResult_count(ctx context.Context, field graphql.CollectedField, obj *model.LicenseAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "LicenseAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _LicenseAggregateResult_idMin(ctx context.Context, field graphql.CollectedField, obj *model.LicenseAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "LicenseAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDMin, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _LicenseAggregateResult_idMax(ctx context.Context, field graphql.CollectedField, obj *model.LicenseAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "LicenseAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDMax, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiPolygon_polygons(ctx context.Context, field graphql.CollectedField, obj *model.MultiPolygon) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "MultiPolygon",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Polygons, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Polygon)
	fc.Result = res
	return ec.marshalNPolygon2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygonᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addPackage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddPackage(rctx, args["input"].([]*model.AddPackageInput))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AddPackagePayload)
	fc.Result = res
	return ec.marshalOAddPackagePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackagePayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updatePackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updatePackage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePackage(rctx, args["input"].(model.UpdatePackageInput))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UpdatePackagePayload)
	fc.Result = res
	return ec.marshalOUpdatePackagePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐUpdatePackagePayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deletePackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deletePackage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePackage(rctx, args["filter"].(model.PackageFilter))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeletePackagePayload)
	fc.Result = res
	return ec.marshalODeletePackagePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDeletePackagePayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addLicense(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addLicense_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddLicense(rctx, args["input"].([]*model.AddLicenseInput), args["upsert"].(*bool))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AddLicensePayload)
	fc.Result = res
	return ec.marshalOAddLicensePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddLicensePayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteLicense(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteLicense_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteLicense(rctx, args["filter"].(model.LicenseFilter))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeleteLicensePayload)
	fc.Result = res
	return ec.marshalODeleteLicensePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDeleteLicensePayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addPackageVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addPackageVersion_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddPackageVersion(rctx, args["input"].([]*model.AddPackageVersionInput), args["upsert"].(*bool))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AddPackageVersionPayload)
	fc.Result = res
	return ec.marshalOAddPackageVersionPayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageVersionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deletePackageVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deletePackageVersion_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePackageVersion(rctx, args["filter"].(model.PackageVersionFilter))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeletePackageVersionPayload)
	fc.Result = res
	return ec.marshalODeletePackageVersionPayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDeletePackageVersionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addProgrammingLanguage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addProgrammingLanguage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddProgrammingLanguage(rctx, args["input"].([]*model.AddProgrammingLanguageInput), args["upsert"].(*bool))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AddProgrammingLanguagePayload)
	fc.Result = res
	return ec.marshalOAddProgrammingLanguagePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddProgrammingLanguagePayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteProgrammingLanguage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteProgrammingLanguage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteProgrammingLanguage(rctx, args["filter"].(model.ProgrammingLanguageFilter))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeleteProgrammingLanguagePayload)
	fc.Result = res
	return ec.marshalODeleteProgrammingLanguagePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDeleteProgrammingLanguagePayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addPackageType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addPackageType_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddPackageType(rctx, args["input"].([]*model.AddPackageTypeInput), args["upsert"].(*bool))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AddPackageTypePayload)
	fc.Result = res
	return ec.marshalOAddPackageTypePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageTypePayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deletePackageType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deletePackageType_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePackageType(rctx, args["filter"].(model.PackageTypeFilter))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeletePackageTypePayload)
	fc.Result = res
	return ec.marshalODeletePackageTypePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDeletePackageTypePayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_name(ctx context.Context, field graphql.CollectedField, obj *model.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Search == nil {
				return nil, errors.New("directive search is not implemented")
			}
			return ec.directives.Search(ctx, obj, directive0, nil)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			key, err := ec.unmarshalNString2string(ctx, "json")
			if err != nil {
				return nil, err
			}
			value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.name")
			if err != nil {
				return nil, err
			}
			if ec.directives.GoTag == nil {
				return nil, errors.New("directive goTag is not implemented")
			}
			return ec.directives.GoTag(ctx, obj, directive1, key, value)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_versions(ctx context.Context, field graphql.CollectedField, obj *model.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Package_versions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Versions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			key, err := ec.unmarshalNString2string(ctx, "json")
			if err != nil {
				return nil, err
			}
			value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.versions")
			if err != nil {
				return nil, err
			}
			if ec.directives.GoTag == nil {
				return nil, errors.New("directive goTag is not implemented")
			}
			return ec.directives.GoTag(ctx, obj, directive0, key, value)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.PackageVersion); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.PackageVersion`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PackageVersion)
	fc.Result = res
	return ec.marshalNPackageVersion2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_licenses(ctx context.Context, field graphql.CollectedField, obj *model.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Package_licenses_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Licenses, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			key, err := ec.unmarshalNString2string(ctx, "json")
			if err != nil {
				return nil, err
			}
			value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.licenses")
			if err != nil {
				return nil, err
			}
			if ec.directives.GoTag == nil {
				return nil, errors.New("directive goTag is not implemented")
			}
			return ec.directives.GoTag(ctx, obj, directive0, key, value)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.License); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.License`, tmp)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.License)
	fc.Result = res
	return ec.marshalOLicense2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicense(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_languages(ctx context.Context, field graphql.CollectedField, obj *model.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Package_languages_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Languages, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			key, err := ec.unmarshalNString2string(ctx, "json")
			if err != nil {
				return nil, err
			}
			value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.languages")
			if err != nil {
				return nil, err
			}
			if ec.directives.GoTag == nil {
				return nil, errors.New("directive goTag is not implemented")
			}
			return ec.directives.GoTag(ctx, obj, directive0, key, value)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ProgrammingLanguage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.ProgrammingLanguage`, tmp)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ProgrammingLanguage)
	fc.Result = res
	return ec.marshalOProgrammingLanguage2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_type(ctx context.Context, field graphql.CollectedField, obj *model.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Package_type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Type, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			key, err := ec.unmarshalNString2string(ctx, "json")
			if err != nil {
				return nil, err
			}
			value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.type")
			if err != nil {
				return nil, err
			}
			if ec.directives.GoTag == nil {
				return nil, errors.New("directive goTag is not implemented")
			}
			return ec.directives.GoTag(ctx, obj, directive0, key, value)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PackageType); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/valllabh/security-cli/graph/model.PackageType`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PackageType)
	fc.Result = res
	return ec.marshalNPackageType2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageType(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_url(ctx context.Context, field graphql.CollectedField, obj *model.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.URL, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Search == nil {
				return nil, errors.New("directive search is not implemented")
			}
			return ec.directives.Search(ctx, obj, directive0, nil)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			key, err := ec.unmarshalNString2string(ctx, "json")
			if err != nil {
				return nil, err
			}
			value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.url")
			if err != nil {
				return nil, err
			}
			if ec.directives.GoTag == nil {
				return nil, errors.New("directive goTag is not implemented")
			}
			return ec.directives.GoTag(ctx, obj, directive1, key, value)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_versionsAggregate(ctx context.Context, field graphql.CollectedField, obj *model.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Package_versionsAggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionsAggregate, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PackageVersionAggregateResult)
	fc.Result = res
	return ec.marshalOPackageVersionAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionAggregateResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_licensesAggregate(ctx context.Context, field graphql.CollectedField, obj *model.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Package_licensesAggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LicensesAggregate, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LicenseAggregateResult)
	fc.Result = res
	return ec.marshalOLicenseAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseAggregateResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_languagesAggregate(ctx context.Context, field graphql.CollectedField, obj *model.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Package_languagesAggregate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LanguagesAggregate, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ProgrammingLanguageAggregateResult)
	fc.Result = res
	return ec.marshalOProgrammingLanguageAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageAggregateResult(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageAggregateResult_count(ctx context.Context, field graphql.CollectedField, obj *model.PackageAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageAggregateResult_nameMin(ctx context.Context, field graphql.CollectedField, obj *model.PackageAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NameMin, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageAggregateResult_nameMax(ctx context.Context, field graphql.CollectedField, obj *model.PackageAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NameMax, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageAggregateResult_urlMin(ctx context.Context, field graphql.CollectedField, obj *model.PackageAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLMin, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageAggregateResult_urlMax(ctx context.Context, field graphql.CollectedField, obj *model.PackageAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLMax, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageType_id(ctx context.Context, field graphql.CollectedField, obj *model.PackageType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageType",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Id == nil {
				return nil, errors.New("directive id is not implemented")
			}
			return ec.directives.Id(ctx, obj, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			key, err := ec.unmarshalNString2string(ctx, "json")
			if err != nil {
				return nil, err
			}
			value, err := ec.unmarshalOString2ᚖstring(ctx, "PackageType.id")
			if err != nil {
				return nil, err
			}
			if ec.directives.GoTag == nil {
				return nil, errors.New("directive goTag is not implemented")
			}
			return ec.directives.GoTag(ctx, obj, directive1, key, value)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageTypeAggregateResult_count(ctx context.Context, field graphql.CollectedField, obj *model.PackageTypeAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageTypeAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageTypeAggregateResult_idMin(ctx context.Context, field graphql.CollectedField, obj *model.PackageTypeAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageTypeAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDMin, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageTypeAggregateResult_idMax(ctx context.Context, field graphql.CollectedField, obj *model.PackageTypeAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageTypeAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDMax, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageVersion_id(ctx context.Context, field graphql.CollectedField, obj *model.PackageVersion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageVersion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Id == nil {
				return nil, errors.New("directive id is not implemented")
			}
			return ec.directives.Id(ctx, obj, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			key, err := ec.unmarshalNString2string(ctx, "json")
			if err != nil {
				return nil, err
			}
			value, err := ec.unmarshalOString2ᚖstring(ctx, "PackageVersion.id")
			if err != nil {
				return nil, err
			}
			if ec.directives.GoTag == nil {
				return nil, errors.New("directive goTag is not implemented")
			}
			return ec.directives.GoTag(ctx, obj, directive1, key, value)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageVersionAggregateResult_count(ctx context.Context, field graphql.CollectedField, obj *model.PackageVersionAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageVersionAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageVersionAggregateResult_idMin(ctx context.Context, field graphql.CollectedField, obj *model.PackageVersionAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageVersionAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDMin, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageVersionAggregateResult_idMax(ctx context.Context, field graphql.CollectedField, obj *model.PackageVersionAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PackageVersionAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDMax, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Point_longitude(ctx context.Context, field graphql.CollectedField, obj *model.Point) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Point",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Longitude, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Point_latitude(ctx context.Context, field graphql.CollectedField, obj *model.Point) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Point",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Latitude, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _PointList_points(ctx context.Context, field graphql.CollectedField, obj *model.PointList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "PointList",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Points, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Point)
	fc.Result = res
	return ec.marshalNPoint2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Polygon_coordinates(ctx context.Context, field graphql.CollectedField, obj *model.Polygon) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Polygon",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Coordinates, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PointList)
	fc.Result = res
	return ec.marshalNPointList2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointListᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ProgrammingLanguage_id(ctx context.Context, field graphql.CollectedField, obj *model.ProgrammingLanguage) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ProgrammingLanguage",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Id == nil {
				return nil, errors.New("directive id is not implemented")
			}
			return ec.directives.Id(ctx, obj, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			key, err := ec.unmarshalNString2string(ctx, "json")
			if err != nil {
				return nil, err
			}
			value, err := ec.unmarshalOString2ᚖstring(ctx, "ProgrammingLanguage.id")
			if err != nil {
				return nil, err
			}
			if ec.directives.GoTag == nil {
				return nil, errors.New("directive goTag is not implemented")
			}
			return ec.directives.GoTag(ctx, obj, directive1, key, value)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ProgrammingLanguageAggregateResult_count(ctx context.Context, field graphql.CollectedField, obj *model.ProgrammingLanguageAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ProgrammingLanguageAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ProgrammingLanguageAggregateResult_idMin(ctx context.Context, field graphql.CollectedField, obj *model.ProgrammingLanguageAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ProgrammingLanguageAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDMin, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ProgrammingLanguageAggregateResult_idMax(ctx context.Context, field graphql.CollectedField, obj *model.ProgrammingLanguageAggregateResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ProgrammingLanguageAggregateResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDMax, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_queryPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_queryPackage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryPackage(rctx, args["filter"].(*model.PackageFilter), args["order"].(*model.PackageOrder), args["first"].(*int), args["offset"].(*int))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Package)
	fc.Result = res
	return ec.marshalOPackage2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_aggregatePackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_aggregatePackage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AggregatePackage(rctx, args["filter"].(*model.PackageFilter))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PackageAggregateResult)
	fc.Result = res
	return ec.marshalOPackageAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageAggregateResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getLicense(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getLicense_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetLicense(rctx, args["id"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.License)
	fc.Result = res
	return ec.marshalOLicense2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicense(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_queryLicense(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_queryLicense_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryLicense(rctx, args["filter"].(*model.LicenseFilter), args["order"].(*model.LicenseOrder), args["first"].(*int), args["offset"].(*int))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.License)
	fc.Result = res
	return ec.marshalOLicense2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicense(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_aggregateLicense(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_aggregateLicense_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AggregateLicense(rctx, args["filter"].(*model.LicenseFilter))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LicenseAggregateResult)
	fc.Result = res
	return ec.marshalOLicenseAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseAggregateResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPackageVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPackageVersion_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetPackageVersion(rctx, args["id"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PackageVersion)
	fc.Result = res
	return ec.marshalOPackageVersion2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_queryPackageVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_queryPackageVersion_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryPackageVersion(rctx, args["filter"].(*model.PackageVersionFilter), args["order"].(*model.PackageVersionOrder), args["first"].(*int), args["offset"].(*int))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PackageVersion)
	fc.Result = res
	return ec.marshalOPackageVersion2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_aggregatePackageVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_aggregatePackageVersion_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AggregatePackageVersion(rctx, args["filter"].(*model.PackageVersionFilter))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PackageVersionAggregateResult)
	fc.Result = res
	return ec.marshalOPackageVersionAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionAggregateResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getProgrammingLanguage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getProgrammingLanguage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetProgrammingLanguage(rctx, args["id"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ProgrammingLanguage)
	fc.Result = res
	return ec.marshalOProgrammingLanguage2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_queryProgrammingLanguage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_queryProgrammingLanguage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryProgrammingLanguage(rctx, args["filter"].(*model.ProgrammingLanguageFilter), args["order"].(*model.ProgrammingLanguageOrder), args["first"].(*int), args["offset"].(*int))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ProgrammingLanguage)
	fc.Result = res
	return ec.marshalOProgrammingLanguage2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_aggregateProgrammingLanguage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_aggregateProgrammingLanguage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AggregateProgrammingLanguage(rctx, args["filter"].(*model.ProgrammingLanguageFilter))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ProgrammingLanguageAggregateResult)
	fc.Result = res
	return ec.marshalOProgrammingLanguageAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageAggregateResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPackageType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPackageType_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetPackageType(rctx, args["id"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PackageType)
	fc.Result = res
	return ec.marshalOPackageType2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_queryPackageType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_queryPackageType_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryPackageType(rctx, args["filter"].(*model.PackageTypeFilter), args["order"].(*model.PackageTypeOrder), args["first"].(*int), args["offset"].(*int))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PackageType)
	fc.Result = res
	return ec.marshalOPackageType2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_aggregatePackageType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_aggregatePackageType_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AggregatePackageType(rctx, args["filter"].(*model.PackageTypeFilter))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PackageTypeAggregateResult)
	fc.Result = res
	return ec.marshalOPackageTypeAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeAggregateResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _UpdatePackagePayload_package(ctx context.Context, field graphql.CollectedField, obj *model.UpdatePackagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "UpdatePackagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_UpdatePackagePayload_package_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Package)
	fc.Result = res
	return ec.marshalOPackage2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _UpdatePackagePayload_numUids(ctx context.Context, field graphql.CollectedField, obj *model.UpdatePackagePayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "UpdatePackagePayload",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUids, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddLicenseInput(ctx context.Context, obj interface{}) (model.AddLicenseInput, error) {
	var it model.AddLicenseInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "License.id")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddPackageInput(ctx context.Context, obj interface{}) (model.AddPackageInput, error) {
	var it model.AddPackageInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.name")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "versions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versions"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalNPackageVersionRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.versions")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.PackageVersionRef); ok {
				it.Versions = data
			} else if tmp == nil {
				it.Versions = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.PackageVersionRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "licenses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenses"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOLicenseRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.licenses")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.LicenseRef); ok {
				it.Licenses = data
			} else if tmp == nil {
				it.Licenses = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.LicenseRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "languages":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languages"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOProgrammingLanguageRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.languages")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.ProgrammingLanguageRef); ok {
				it.Languages = data
			} else if tmp == nil {
				it.Languages = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.ProgrammingLanguageRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalNPackageTypeRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.type")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.PackageTypeRef); ok {
				it.Type = data
			} else if tmp == nil {
				it.Type = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/valllabh/security-cli/graph/model.PackageTypeRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.url")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.URL = data
			} else if tmp == nil {
				it.URL = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddPackageTypeInput(ctx context.Context, obj interface{}) (model.AddPackageTypeInput, error) {
	var it model.AddPackageTypeInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "PackageType.id")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddPackageVersionInput(ctx context.Context, obj interface{}) (model.AddPackageVersionInput, error) {
	var it model.AddPackageVersionInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "PackageVersion.id")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddProgrammingLanguageInput(ctx context.Context, obj interface{}) (model.AddProgrammingLanguageInput, error) {
	var it model.AddProgrammingLanguageInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "ProgrammingLanguage.id")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthRule(ctx context.Context, obj interface{}) (model.AuthRule, error) {
	var it model.AuthRule
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOAuthRule2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAuthRule(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOAuthRule2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAuthRule(ctx, v)
			if err != nil {
				return it, err
			}
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOAuthRule2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAuthRule(ctx, v)
			if err != nil {
				return it, err
			}
		case "rule":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rule"))
			it.Rule, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputContainsFilter(ctx context.Context, obj interface{}) (model.ContainsFilter, error) {
	var it model.ContainsFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "point":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("point"))
			it.Point, err = ec.unmarshalOPointRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointRef(ctx, v)
			if err != nil {
				return it, err
			}
		case "polygon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("polygon"))
			it.Polygon, err = ec.unmarshalOPolygonRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygonRef(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCustomHTTP(ctx context.Context, obj interface{}) (model.CustomHTTP, error) {
	var it model.CustomHTTP
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			it.URL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "method":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("method"))
			it.Method, err = ec.unmarshalNHTTPMethod2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐHTTPMethod(ctx, v)
			if err != nil {
				return it, err
			}
		case "body":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("body"))
			it.Body, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "graphql":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("graphql"))
			it.Graphql, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "mode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			it.Mode, err = ec.unmarshalOMode2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐMode(ctx, v)
			if err != nil {
				return it, err
			}
		case "forwardHeaders":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forwardHeaders"))
			it.ForwardHeaders, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "secretHeaders":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretHeaders"))
			it.SecretHeaders, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "introspectionHeaders":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("introspectionHeaders"))
			it.IntrospectionHeaders, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipIntrospection":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skipIntrospection"))
			it.SkipIntrospection, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDateTimeFilter(ctx context.Context, obj interface{}) (model.DateTimeFilter, error) {
	var it model.DateTimeFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
			it.In, err = ec.unmarshalODateTime2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "le":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("le"))
			it.Le, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			it.Lt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "ge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ge"))
			it.Ge, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			it.Gt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "between":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("between"))
			it.Between, err = ec.unmarshalODateTimeRange2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDateTimeRange(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDateTimeRange(ctx context.Context, obj interface{}) (model.DateTimeRange, error) {
	var it model.DateTimeRange
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "min":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
			it.Min, err = ec.unmarshalNDateTime2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "max":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			it.Max, err = ec.unmarshalNDateTime2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFloatFilter(ctx context.Context, obj interface{}) (model.FloatFilter, error) {
	var it model.FloatFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
			it.In, err = ec.unmarshalOFloat2ᚕᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "le":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("le"))
			it.Le, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			it.Lt, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "ge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ge"))
			it.Ge, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			it.Gt, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "between":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("between"))
			it.Between, err = ec.unmarshalOFloatRange2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐFloatRange(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFloatRange(ctx context.Context, obj interface{}) (model.FloatRange, error) {
	var it model.FloatRange
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "min":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
			it.Min, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "max":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			it.Max, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGenerateMutationParams(ctx context.Context, obj interface{}) (model.GenerateMutationParams, error) {
	var it model.GenerateMutationParams
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "add":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("add"))
			it.Add, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "update":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("update"))
			it.Update, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "delete":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("delete"))
			it.Delete, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGenerateQueryParams(ctx context.Context, obj interface{}) (model.GenerateQueryParams, error) {
	var it model.GenerateQueryParams
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "get":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("get"))
			it.Get, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "query":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			it.Query, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			it.Password, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "aggregate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aggregate"))
			it.Aggregate, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInt64Filter(ctx context.Context, obj interface{}) (model.Int64Filter, error) {
	var it model.Int64Filter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOInt642ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
			it.In, err = ec.unmarshalOInt642ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "le":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("le"))
			it.Le, err = ec.unmarshalOInt642ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			it.Lt, err = ec.unmarshalOInt642ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "ge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ge"))
			it.Ge, err = ec.unmarshalOInt642ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			it.Gt, err = ec.unmarshalOInt642ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "between":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("between"))
			it.Between, err = ec.unmarshalOInt64Range2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐInt64Range(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInt64Range(ctx context.Context, obj interface{}) (model.Int64Range, error) {
	var it model.Int64Range
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "min":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
			it.Min, err = ec.unmarshalNInt642string(ctx, v)
			if err != nil {
				return it, err
			}
		case "max":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			it.Max, err = ec.unmarshalNInt642string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntFilter(ctx context.Context, obj interface{}) (model.IntFilter, error) {
	var it model.IntFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
			it.In, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "le":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("le"))
			it.Le, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			it.Lt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ge"))
			it.Ge, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			it.Gt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "between":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("between"))
			it.Between, err = ec.unmarshalOIntRange2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐIntRange(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntRange(ctx context.Context, obj interface{}) (model.IntRange, error) {
	var it model.IntRange
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "min":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
			it.Min, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "max":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			it.Max, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntersectsFilter(ctx context.Context, obj interface{}) (model.IntersectsFilter, error) {
	var it model.IntersectsFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "polygon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("polygon"))
			it.Polygon, err = ec.unmarshalOPolygonRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygonRef(ctx, v)
			if err != nil {
				return it, err
			}
		case "multiPolygon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("multiPolygon"))
			it.MultiPolygon, err = ec.unmarshalOMultiPolygonRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐMultiPolygonRef(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLicenseFilter(ctx context.Context, obj interface{}) (model.LicenseFilter, error) {
	var it model.LicenseFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOStringHashFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐStringHashFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "has":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("has"))
			it.Has, err = ec.unmarshalOLicenseHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseHasFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOLicenseFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOLicenseFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOLicenseFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLicenseOrder(ctx context.Context, obj interface{}) (model.LicenseOrder, error) {
	var it model.LicenseOrder
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "asc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asc"))
			it.Asc, err = ec.unmarshalOLicenseOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseOrderable(ctx, v)
			if err != nil {
				return it, err
			}
		case "desc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("desc"))
			it.Desc, err = ec.unmarshalOLicenseOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseOrderable(ctx, v)
			if err != nil {
				return it, err
			}
		case "then":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("then"))
			it.Then, err = ec.unmarshalOLicenseOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseOrder(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLicenseRef(ctx context.Context, obj interface{}) (model.LicenseRef, error) {
	var it model.LicenseRef
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "License.id")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMultiPolygonRef(ctx context.Context, obj interface{}) (model.MultiPolygonRef, error) {
	var it model.MultiPolygonRef
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "polygons":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("polygons"))
			it.Polygons, err = ec.unmarshalNPolygonRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygonRefᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNearFilter(ctx context.Context, obj interface{}) (model.NearFilter, error) {
	var it model.NearFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "distance":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distance"))
			it.Distance, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "coordinate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coordinate"))
			it.Coordinate, err = ec.unmarshalNPointRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointRef(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageFilter(ctx context.Context, obj interface{}) (model.PackageFilter, error) {
	var it model.PackageFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOStringTermFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐStringTermFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			it.URL, err = ec.unmarshalOStringTermFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐStringTermFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "has":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("has"))
			it.Has, err = ec.unmarshalOPackageHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageHasFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOPackageFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOPackageFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOPackageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageOrder(ctx context.Context, obj interface{}) (model.PackageOrder, error) {
	var it model.PackageOrder
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "asc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asc"))
			it.Asc, err = ec.unmarshalOPackageOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageOrderable(ctx, v)
			if err != nil {
				return it, err
			}
		case "desc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("desc"))
			it.Desc, err = ec.unmarshalOPackageOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageOrderable(ctx, v)
			if err != nil {
				return it, err
			}
		case "then":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("then"))
			it.Then, err = ec.unmarshalOPackageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageOrder(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackagePatch(ctx context.Context, obj interface{}) (model.PackagePatch, error) {
	var it model.PackagePatch
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.name")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "versions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versions"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOPackageVersionRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.versions")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.PackageVersionRef); ok {
				it.Versions = data
			} else if tmp == nil {
				it.Versions = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.PackageVersionRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "licenses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenses"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOLicenseRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.licenses")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.LicenseRef); ok {
				it.Licenses = data
			} else if tmp == nil {
				it.Licenses = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.LicenseRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "languages":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languages"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOProgrammingLanguageRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.languages")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.ProgrammingLanguageRef); ok {
				it.Languages = data
			} else if tmp == nil {
				it.Languages = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.ProgrammingLanguageRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOPackageTypeRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.type")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.PackageTypeRef); ok {
				it.Type = data
			} else if tmp == nil {
				it.Type = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/valllabh/security-cli/graph/model.PackageTypeRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.url")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.URL = data
			} else if tmp == nil {
				it.URL = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageRef(ctx context.Context, obj interface{}) (model.PackageRef, error) {
	var it model.PackageRef
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.name")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "versions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versions"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOPackageVersionRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.versions")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.PackageVersionRef); ok {
				it.Versions = data
			} else if tmp == nil {
				it.Versions = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.PackageVersionRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "licenses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenses"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOLicenseRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.licenses")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.LicenseRef); ok {
				it.Licenses = data
			} else if tmp == nil {
				it.Licenses = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.LicenseRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "languages":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languages"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOProgrammingLanguageRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.languages")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.ProgrammingLanguageRef); ok {
				it.Languages = data
			} else if tmp == nil {
				it.Languages = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/valllabh/security-cli/graph/model.ProgrammingLanguageRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOPackageTypeRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeRef(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.type")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.PackageTypeRef); ok {
				it.Type = data
			} else if tmp == nil {
				it.Type = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/valllabh/security-cli/graph/model.PackageTypeRef`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "Package.url")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.URL = data
			} else if tmp == nil {
				it.URL = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageTypeFilter(ctx context.Context, obj interface{}) (model.PackageTypeFilter, error) {
	var it model.PackageTypeFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOStringHashFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐStringHashFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "has":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("has"))
			it.Has, err = ec.unmarshalOPackageTypeHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeHasFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOPackageTypeFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOPackageTypeFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOPackageTypeFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageTypeOrder(ctx context.Context, obj interface{}) (model.PackageTypeOrder, error) {
	var it model.PackageTypeOrder
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "asc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asc"))
			it.Asc, err = ec.unmarshalOPackageTypeOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeOrderable(ctx, v)
			if err != nil {
				return it, err
			}
		case "desc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("desc"))
			it.Desc, err = ec.unmarshalOPackageTypeOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeOrderable(ctx, v)
			if err != nil {
				return it, err
			}
		case "then":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("then"))
			it.Then, err = ec.unmarshalOPackageTypeOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeOrder(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageTypeRef(ctx context.Context, obj interface{}) (model.PackageTypeRef, error) {
	var it model.PackageTypeRef
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "PackageType.id")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageVersionFilter(ctx context.Context, obj interface{}) (model.PackageVersionFilter, error) {
	var it model.PackageVersionFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOStringHashFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐStringHashFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "has":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("has"))
			it.Has, err = ec.unmarshalOPackageVersionHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionHasFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOPackageVersionFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOPackageVersionFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOPackageVersionFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageVersionOrder(ctx context.Context, obj interface{}) (model.PackageVersionOrder, error) {
	var it model.PackageVersionOrder
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "asc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asc"))
			it.Asc, err = ec.unmarshalOPackageVersionOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionOrderable(ctx, v)
			if err != nil {
				return it, err
			}
		case "desc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("desc"))
			it.Desc, err = ec.unmarshalOPackageVersionOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionOrderable(ctx, v)
			if err != nil {
				return it, err
			}
		case "then":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("then"))
			it.Then, err = ec.unmarshalOPackageVersionOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionOrder(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageVersionRef(ctx context.Context, obj interface{}) (model.PackageVersionRef, error) {
	var it model.PackageVersionRef
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "PackageVersion.id")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPointGeoFilter(ctx context.Context, obj interface{}) (model.PointGeoFilter, error) {
	var it model.PointGeoFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "near":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			it.Near, err = ec.unmarshalONearFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐNearFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "within":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			it.Within, err = ec.unmarshalOWithinFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐWithinFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPointListRef(ctx context.Context, obj interface{}) (model.PointListRef, error) {
	var it model.PointListRef
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "points":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("points"))
			it.Points, err = ec.unmarshalNPointRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointRefᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPointRef(ctx context.Context, obj interface{}) (model.PointRef, error) {
	var it model.PointRef
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "longitude":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("longitude"))
			it.Longitude, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "latitude":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("latitude"))
			it.Latitude, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPolygonGeoFilter(ctx context.Context, obj interface{}) (model.PolygonGeoFilter, error) {
	var it model.PolygonGeoFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "near":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			it.Near, err = ec.unmarshalONearFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐNearFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "within":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			it.Within, err = ec.unmarshalOWithinFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐWithinFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "contains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contains"))
			it.Contains, err = ec.unmarshalOContainsFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐContainsFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "intersects":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("intersects"))
			it.Intersects, err = ec.unmarshalOIntersectsFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐIntersectsFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPolygonRef(ctx context.Context, obj interface{}) (model.PolygonRef, error) {
	var it model.PolygonRef
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "coordinates":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coordinates"))
			it.Coordinates, err = ec.unmarshalNPointListRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointListRefᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProgrammingLanguageFilter(ctx context.Context, obj interface{}) (model.ProgrammingLanguageFilter, error) {
	var it model.ProgrammingLanguageFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOStringHashFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐStringHashFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "has":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("has"))
			it.Has, err = ec.unmarshalOProgrammingLanguageHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageHasFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOProgrammingLanguageFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOProgrammingLanguageFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOProgrammingLanguageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProgrammingLanguageOrder(ctx context.Context, obj interface{}) (model.ProgrammingLanguageOrder, error) {
	var it model.ProgrammingLanguageOrder
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "asc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asc"))
			it.Asc, err = ec.unmarshalOProgrammingLanguageOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageOrderable(ctx, v)
			if err != nil {
				return it, err
			}
		case "desc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("desc"))
			it.Desc, err = ec.unmarshalOProgrammingLanguageOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageOrderable(ctx, v)
			if err != nil {
				return it, err
			}
		case "then":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("then"))
			it.Then, err = ec.unmarshalOProgrammingLanguageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageOrder(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProgrammingLanguageRef(ctx context.Context, obj interface{}) (model.ProgrammingLanguageRef, error) {
	var it model.ProgrammingLanguageRef
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				key, err := ec.unmarshalNString2string(ctx, "json")
				if err != nil {
					return nil, err
				}
				value, err := ec.unmarshalOString2ᚖstring(ctx, "ProgrammingLanguage.id")
				if err != nil {
					return nil, err
				}
				if ec.directives.GoTag == nil {
					return nil, errors.New("directive goTag is not implemented")
				}
				return ec.directives.GoTag(ctx, obj, directive0, key, value)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringExactFilter(ctx context.Context, obj interface{}) (model.StringExactFilter, error) {
	var it model.StringExactFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
			it.In, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "le":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("le"))
			it.Le, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			it.Lt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "ge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ge"))
			it.Ge, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			it.Gt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "between":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("between"))
			it.Between, err = ec.unmarshalOStringRange2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐStringRange(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringFullTextFilter(ctx context.Context, obj interface{}) (model.StringFullTextFilter, error) {
	var it model.StringFullTextFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "alloftext":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alloftext"))
			it.Alloftext, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "anyoftext":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("anyoftext"))
			it.Anyoftext, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringHashFilter(ctx context.Context, obj interface{}) (model.StringHashFilter, error) {
	var it model.StringHashFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "in":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
			it.In, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringRange(ctx context.Context, obj interface{}) (model.StringRange, error) {
	var it model.StringRange
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "min":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
			it.Min, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "max":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			it.Max, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringRegExpFilter(ctx context.Context, obj interface{}) (model.StringRegExpFilter, error) {
	var it model.StringRegExpFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "regexp":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regexp"))
			it.Regexp, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringTermFilter(ctx context.Context, obj interface{}) (model.StringTermFilter, error) {
	var it model.StringTermFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "allofterms":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allofterms"))
			it.Allofterms, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "anyofterms":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("anyofterms"))
			it.Anyofterms, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePackageInput(ctx context.Context, obj interface{}) (model.UpdatePackageInput, error) {
	var it model.UpdatePackageInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "filter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			it.Filter, err = ec.unmarshalNPackageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "set":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("set"))
			it.Set, err = ec.unmarshalOPackagePatch2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackagePatch(ctx, v)
			if err != nil {
				return it, err
			}
		case "remove":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remove"))
			it.Remove, err = ec.unmarshalOPackagePatch2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackagePatch(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWithinFilter(ctx context.Context, obj interface{}) (model.WithinFilter, error) {
	var it model.WithinFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "polygon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("polygon"))
			it.Polygon, err = ec.unmarshalNPolygonRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygonRef(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var addLicensePayloadImplementors = []string{"AddLicensePayload"}

func (ec *executionContext) _AddLicensePayload(ctx context.Context, sel ast.SelectionSet, obj *model.AddLicensePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addLicensePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddLicensePayload")
		case "license":
			out.Values[i] = ec._AddLicensePayload_license(ctx, field, obj)
		case "numUids":
			out.Values[i] = ec._AddLicensePayload_numUids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var addPackagePayloadImplementors = []string{"AddPackagePayload"}

func (ec *executionContext) _AddPackagePayload(ctx context.Context, sel ast.SelectionSet, obj *model.AddPackagePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addPackagePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddPackagePayload")
		case "package":
			out.Values[i] = ec._AddPackagePayload_package(ctx, field, obj)
		case "numUids":
			out.Values[i] = ec._AddPackagePayload_numUids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var addPackageTypePayloadImplementors = []string{"AddPackageTypePayload"}

func (ec *executionContext) _AddPackageTypePayload(ctx context.Context, sel ast.SelectionSet, obj *model.AddPackageTypePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addPackageTypePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddPackageTypePayload")
		case "packageType":
			out.Values[i] = ec._AddPackageTypePayload_packageType(ctx, field, obj)
		case "numUids":
			out.Values[i] = ec._AddPackageTypePayload_numUids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var addPackageVersionPayloadImplementors = []string{"AddPackageVersionPayload"}

func (ec *executionContext) _AddPackageVersionPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AddPackageVersionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addPackageVersionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddPackageVersionPayload")
		case "packageVersion":
			out.Values[i] = ec._AddPackageVersionPayload_packageVersion(ctx, field, obj)
		case "numUids":
			out.Values[i] = ec._AddPackageVersionPayload_numUids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var addProgrammingLanguagePayloadImplementors = []string{"AddProgrammingLanguagePayload"}

func (ec *executionContext) _AddProgrammingLanguagePayload(ctx context.Context, sel ast.SelectionSet, obj *model.AddProgrammingLanguagePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addProgrammingLanguagePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddProgrammingLanguagePayload")
		case "programmingLanguage":
			out.Values[i] = ec._AddProgrammingLanguagePayload_programmingLanguage(ctx, field, obj)
		case "numUids":
			out.Values[i] = ec._AddProgrammingLanguagePayload_numUids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deleteLicensePayloadImplementors = []string{"DeleteLicensePayload"}

func (ec *executionContext) _DeleteLicensePayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteLicensePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteLicensePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteLicensePayload")
		case "license":
			out.Values[i] = ec._DeleteLicensePayload_license(ctx, field, obj)
		case "msg":
			out.Values[i] = ec._DeleteLicensePayload_msg(ctx, field, obj)
		case "numUids":
			out.Values[i] = ec._DeleteLicensePayload_numUids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deletePackagePayloadImplementors = []string{"DeletePackagePayload"}

func (ec *executionContext) _DeletePackagePayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeletePackagePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deletePackagePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeletePackagePayload")
		case "package":
			out.Values[i] = ec._DeletePackagePayload_package(ctx, field, obj)
		case "msg":
			out.Values[i] = ec._DeletePackagePayload_msg(ctx, field, obj)
		case "numUids":
			out.Values[i] = ec._DeletePackagePayload_numUids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deletePackageTypePayloadImplementors = []string{"DeletePackageTypePayload"}

func (ec *executionContext) _DeletePackageTypePayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeletePackageTypePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deletePackageTypePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeletePackageTypePayload")
		case "packageType":
			out.Values[i] = ec._DeletePackageTypePayload_packageType(ctx, field, obj)
		case "msg":
			out.Values[i] = ec._DeletePackageTypePayload_msg(ctx, field, obj)
		case "numUids":
			out.Values[i] = ec._DeletePackageTypePayload_numUids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deletePackageVersionPayloadImplementors = []string{"DeletePackageVersionPayload"}

func (ec *executionContext) _DeletePackageVersionPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeletePackageVersionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deletePackageVersionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeletePackageVersionPayload")
		case "packageVersion":
			out.Values[i] = ec._DeletePackageVersionPayload_packageVersion(ctx, field, obj)
		case "msg":
			out.Values[i] = ec._DeletePackageVersionPayload_msg(ctx, field, obj)
		case "numUids":
			out.Values[i] = ec._DeletePackageVersionPayload_numUids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deleteProgrammingLanguagePayloadImplementors = []string{"DeleteProgrammingLanguagePayload"}

func (ec *executionContext) _DeleteProgrammingLanguagePayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteProgrammingLanguagePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteProgrammingLanguagePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteProgrammingLanguagePayload")
		case "programmingLanguage":
			out.Values[i] = ec._DeleteProgrammingLanguagePayload_programmingLanguage(ctx, field, obj)
		case "msg":
			out.Values[i] = ec._DeleteProgrammingLanguagePayload_msg(ctx, field, obj)
		case "numUids":
			out.Values[i] = ec._DeleteProgrammingLanguagePayload_numUids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var licenseImplementors = []string{"License"}

func (ec *executionContext) _License(ctx context.Context, sel ast.SelectionSet, obj *model.License) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, licenseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("License")
		case "id":
			out.Values[i] = ec._License_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var licenseAggregateResultImplementors = []string{"LicenseAggregateResult"}

func (ec *executionContext) _LicenseAggregateResult(ctx context.Context, sel ast.SelectionSet, obj *model.LicenseAggregateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, licenseAggregateResultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LicenseAggregateResult")
		case "count":
			out.Values[i] = ec._LicenseAggregateResult_count(ctx, field, obj)
		case "idMin":
			out.Values[i] = ec._LicenseAggregateResult_idMin(ctx, field, obj)
		case "idMax":
			out.Values[i] = ec._LicenseAggregateResult_idMax(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var multiPolygonImplementors = []string{"MultiPolygon"}

func (ec *executionContext) _MultiPolygon(ctx context.Context, sel ast.SelectionSet, obj *model.MultiPolygon) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, multiPolygonImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MultiPolygon")
		case "polygons":
			out.Values[i] = ec._MultiPolygon_polygons(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "addPackage":
			out.Values[i] = ec._Mutation_addPackage(ctx, field)
		case "updatePackage":
			out.Values[i] = ec._Mutation_updatePackage(ctx, field)
		case "deletePackage":
			out.Values[i] = ec._Mutation_deletePackage(ctx, field)
		case "addLicense":
			out.Values[i] = ec._Mutation_addLicense(ctx, field)
		case "deleteLicense":
			out.Values[i] = ec._Mutation_deleteLicense(ctx, field)
		case "addPackageVersion":
			out.Values[i] = ec._Mutation_addPackageVersion(ctx, field)
		case "deletePackageVersion":
			out.Values[i] = ec._Mutation_deletePackageVersion(ctx, field)
		case "addProgrammingLanguage":
			out.Values[i] = ec._Mutation_addProgrammingLanguage(ctx, field)
		case "deleteProgrammingLanguage":
			out.Values[i] = ec._Mutation_deleteProgrammingLanguage(ctx, field)
		case "addPackageType":
			out.Values[i] = ec._Mutation_addPackageType(ctx, field)
		case "deletePackageType":
			out.Values[i] = ec._Mutation_deletePackageType(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageImplementors = []string{"Package"}

func (ec *executionContext) _Package(ctx context.Context, sel ast.SelectionSet, obj *model.Package) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Package")
		case "name":
			out.Values[i] = ec._Package_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "versions":
			out.Values[i] = ec._Package_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "licenses":
			out.Values[i] = ec._Package_licenses(ctx, field, obj)
		case "languages":
			out.Values[i] = ec._Package_languages(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Package_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":
			out.Values[i] = ec._Package_url(ctx, field, obj)
		case "versionsAggregate":
			out.Values[i] = ec._Package_versionsAggregate(ctx, field, obj)
		case "licensesAggregate":
			out.Values[i] = ec._Package_licensesAggregate(ctx, field, obj)
		case "languagesAggregate":
			out.Values[i] = ec._Package_languagesAggregate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageAggregateResultImplementors = []string{"PackageAggregateResult"}

func (ec *executionContext) _PackageAggregateResult(ctx context.Context, sel ast.SelectionSet, obj *model.PackageAggregateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageAggregateResultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PackageAggregateResult")
		case "count":
			out.Values[i] = ec._PackageAggregateResult_count(ctx, field, obj)
		case "nameMin":
			out.Values[i] = ec._PackageAggregateResult_nameMin(ctx, field, obj)
		case "nameMax":
			out.Values[i] = ec._PackageAggregateResult_nameMax(ctx, field, obj)
		case "urlMin":
			out.Values[i] = ec._PackageAggregateResult_urlMin(ctx, field, obj)
		case "urlMax":
			out.Values[i] = ec._PackageAggregateResult_urlMax(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageTypeImplementors = []string{"PackageType"}

func (ec *executionContext) _PackageType(ctx context.Context, sel ast.SelectionSet, obj *model.PackageType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageTypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PackageType")
		case "id":
			out.Values[i] = ec._PackageType_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageTypeAggregateResultImplementors = []string{"PackageTypeAggregateResult"}

func (ec *executionContext) _PackageTypeAggregateResult(ctx context.Context, sel ast.SelectionSet, obj *model.PackageTypeAggregateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageTypeAggregateResultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PackageTypeAggregateResult")
		case "count":
			out.Values[i] = ec._PackageTypeAggregateResult_count(ctx, field, obj)
		case "idMin":
			out.Values[i] = ec._PackageTypeAggregateResult_idMin(ctx, field, obj)
		case "idMax":
			out.Values[i] = ec._PackageTypeAggregateResult_idMax(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageVersionImplementors = []string{"PackageVersion"}

func (ec *executionContext) _PackageVersion(ctx context.Context, sel ast.SelectionSet, obj *model.PackageVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageVersionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PackageVersion")
		case "id":
			out.Values[i] = ec._PackageVersion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageVersionAggregateResultImplementors = []string{"PackageVersionAggregateResult"}

func (ec *executionContext) _PackageVersionAggregateResult(ctx context.Context, sel ast.SelectionSet, obj *model.PackageVersionAggregateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageVersionAggregateResultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PackageVersionAggregateResult")
		case "count":
			out.Values[i] = ec._PackageVersionAggregateResult_count(ctx, field, obj)
		case "idMin":
			out.Values[i] = ec._PackageVersionAggregateResult_idMin(ctx, field, obj)
		case "idMax":
			out.Values[i] = ec._PackageVersionAggregateResult_idMax(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pointImplementors = []string{"Point"}

func (ec *executionContext) _Point(ctx context.Context, sel ast.SelectionSet, obj *model.Point) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pointImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Point")
		case "longitude":
			out.Values[i] = ec._Point_longitude(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "latitude":
			out.Values[i] = ec._Point_latitude(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pointListImplementors = []string{"PointList"}

func (ec *executionContext) _PointList(ctx context.Context, sel ast.SelectionSet, obj *model.PointList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pointListImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PointList")
		case "points":
			out.Values[i] = ec._PointList_points(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var polygonImplementors = []string{"Polygon"}

func (ec *executionContext) _Polygon(ctx context.Context, sel ast.SelectionSet, obj *model.Polygon) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, polygonImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Polygon")
		case "coordinates":
			out.Values[i] = ec._Polygon_coordinates(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var programmingLanguageImplementors = []string{"ProgrammingLanguage"}

func (ec *executionContext) _ProgrammingLanguage(ctx context.Context, sel ast.SelectionSet, obj *model.ProgrammingLanguage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, programmingLanguageImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProgrammingLanguage")
		case "id":
			out.Values[i] = ec._ProgrammingLanguage_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var programmingLanguageAggregateResultImplementors = []string{"ProgrammingLanguageAggregateResult"}

func (ec *executionContext) _ProgrammingLanguageAggregateResult(ctx context.Context, sel ast.SelectionSet, obj *model.ProgrammingLanguageAggregateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, programmingLanguageAggregateResultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProgrammingLanguageAggregateResult")
		case "count":
			out.Values[i] = ec._ProgrammingLanguageAggregateResult_count(ctx, field, obj)
		case "idMin":
			out.Values[i] = ec._ProgrammingLanguageAggregateResult_idMin(ctx, field, obj)
		case "idMax":
			out.Values[i] = ec._ProgrammingLanguageAggregateResult_idMax(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "queryPackage":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryPackage(ctx, field)
				return res
			})
		case "aggregatePackage":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_aggregatePackage(ctx, field)
				return res
			})
		case "getLicense":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getLicense(ctx, field)
				return res
			})
		case "queryLicense":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryLicense(ctx, field)
				return res
			})
		case "aggregateLicense":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_aggregateLicense(ctx, field)
				return res
			})
		case "getPackageVersion":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPackageVersion(ctx, field)
				return res
			})
		case "queryPackageVersion":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryPackageVersion(ctx, field)
				return res
			})
		case "aggregatePackageVersion":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_aggregatePackageVersion(ctx, field)
				return res
			})
		case "getProgrammingLanguage":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getProgrammingLanguage(ctx, field)
				return res
			})
		case "queryProgrammingLanguage":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryProgrammingLanguage(ctx, field)
				return res
			})
		case "aggregateProgrammingLanguage":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_aggregateProgrammingLanguage(ctx, field)
				return res
			})
		case "getPackageType":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPackageType(ctx, field)
				return res
			})
		case "queryPackageType":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryPackageType(ctx, field)
				return res
			})
		case "aggregatePackageType":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_aggregatePackageType(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updatePackagePayloadImplementors = []string{"UpdatePackagePayload"}

func (ec *executionContext) _UpdatePackagePayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdatePackagePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updatePackagePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdatePackagePayload")
		case "package":
			out.Values[i] = ec._UpdatePackagePayload_package(ctx, field, obj)
		case "numUids":
			out.Values[i] = ec._UpdatePackagePayload_numUids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddLicenseInput2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddLicenseInputᚄ(ctx context.Context, v interface{}) ([]*model.AddLicenseInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.AddLicenseInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAddLicenseInput2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddLicenseInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNAddLicenseInput2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddLicenseInput(ctx context.Context, v interface{}) (*model.AddLicenseInput, error) {
	res, err := ec.unmarshalInputAddLicenseInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAddPackageInput2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageInputᚄ(ctx context.Context, v interface{}) ([]*model.AddPackageInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.AddPackageInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAddPackageInput2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNAddPackageInput2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageInput(ctx context.Context, v interface{}) (*model.AddPackageInput, error) {
	res, err := ec.unmarshalInputAddPackageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAddPackageTypeInput2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageTypeInputᚄ(ctx context.Context, v interface{}) ([]*model.AddPackageTypeInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.AddPackageTypeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAddPackageTypeInput2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageTypeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNAddPackageTypeInput2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageTypeInput(ctx context.Context, v interface{}) (*model.AddPackageTypeInput, error) {
	res, err := ec.unmarshalInputAddPackageTypeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAddPackageVersionInput2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageVersionInputᚄ(ctx context.Context, v interface{}) ([]*model.AddPackageVersionInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.AddPackageVersionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAddPackageVersionInput2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageVersionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNAddPackageVersionInput2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageVersionInput(ctx context.Context, v interface{}) (*model.AddPackageVersionInput, error) {
	res, err := ec.unmarshalInputAddPackageVersionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAddProgrammingLanguageInput2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddProgrammingLanguageInputᚄ(ctx context.Context, v interface{}) ([]*model.AddProgrammingLanguageInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.AddProgrammingLanguageInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAddProgrammingLanguageInput2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddProgrammingLanguageInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNAddProgrammingLanguageInput2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddProgrammingLanguageInput(ctx context.Context, v interface{}) (*model.AddProgrammingLanguageInput, error) {
	res, err := ec.unmarshalInputAddProgrammingLanguageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDateTime2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDgraphIndex2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDgraphIndex(ctx context.Context, v interface{}) (model.DgraphIndex, error) {
	var res model.DgraphIndex
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDgraphIndex2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDgraphIndex(ctx context.Context, sel ast.SelectionSet, v model.DgraphIndex) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNHTTPMethod2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐHTTPMethod(ctx context.Context, v interface{}) (model.HTTPMethod, error) {
	var res model.HTTPMethod
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHTTPMethod2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐHTTPMethod(ctx context.Context, sel ast.SelectionSet, v model.HTTPMethod) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt642string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt642string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNLicenseFilter2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx context.Context, v interface{}) (model.LicenseFilter, error) {
	res, err := ec.unmarshalInputLicenseFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPackageFilter2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx context.Context, v interface{}) (model.PackageFilter, error) {
	res, err := ec.unmarshalInputPackageFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPackageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx context.Context, v interface{}) (*model.PackageFilter, error) {
	res, err := ec.unmarshalInputPackageFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPackageType2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageType(ctx context.Context, sel ast.SelectionSet, v *model.PackageType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PackageType(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPackageTypeFilter2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx context.Context, v interface{}) (model.PackageTypeFilter, error) {
	res, err := ec.unmarshalInputPackageTypeFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPackageTypeRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeRef(ctx context.Context, v interface{}) (*model.PackageTypeRef, error) {
	res, err := ec.unmarshalInputPackageTypeRef(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPackageVersion2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersion(ctx context.Context, sel ast.SelectionSet, v []*model.PackageVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPackageVersion2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNPackageVersionFilter2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx context.Context, v interface{}) (model.PackageVersionFilter, error) {
	res, err := ec.unmarshalInputPackageVersionFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPackageVersionRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionRef(ctx context.Context, v interface{}) ([]*model.PackageVersionRef, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PackageVersionRef, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOPackageVersionRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionRef(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNPoint2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Point) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPoint2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPoint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPoint2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPoint(ctx context.Context, sel ast.SelectionSet, v *model.Point) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Point(ctx, sel, v)
}

func (ec *executionContext) marshalNPointList2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointListᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.PointList) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPointList2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointList(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPointList2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointList(ctx context.Context, sel ast.SelectionSet, v *model.PointList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PointList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPointListRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointListRefᚄ(ctx context.Context, v interface{}) ([]*model.PointListRef, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PointListRef, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPointListRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointListRef(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPointListRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointListRef(ctx context.Context, v interface{}) (*model.PointListRef, error) {
	res, err := ec.unmarshalInputPointListRef(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPointRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointRefᚄ(ctx context.Context, v interface{}) ([]*model.PointRef, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PointRef, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPointRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointRef(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPointRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointRef(ctx context.Context, v interface{}) (*model.PointRef, error) {
	res, err := ec.unmarshalInputPointRef(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPolygon2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygonᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Polygon) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPolygon2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygon(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPolygon2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygon(ctx context.Context, sel ast.SelectionSet, v *model.Polygon) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Polygon(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPolygonRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygonRefᚄ(ctx context.Context, v interface{}) ([]*model.PolygonRef, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PolygonRef, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPolygonRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygonRef(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPolygonRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygonRef(ctx context.Context, v interface{}) (*model.PolygonRef, error) {
	res, err := ec.unmarshalInputPolygonRef(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNProgrammingLanguageFilter2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx context.Context, v interface{}) (model.ProgrammingLanguageFilter, error) {
	res, err := ec.unmarshalInputProgrammingLanguageFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdatePackageInput2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐUpdatePackageInput(ctx context.Context, v interface{}) (model.UpdatePackageInput, error) {
	res, err := ec.unmarshalInputUpdatePackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalOAddLicensePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddLicensePayload(ctx context.Context, sel ast.SelectionSet, v *model.AddLicensePayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AddLicensePayload(ctx, sel, v)
}

func (ec *executionContext) marshalOAddPackagePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackagePayload(ctx context.Context, sel ast.SelectionSet, v *model.AddPackagePayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AddPackagePayload(ctx, sel, v)
}

func (ec *executionContext) marshalOAddPackageTypePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageTypePayload(ctx context.Context, sel ast.SelectionSet, v *model.AddPackageTypePayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AddPackageTypePayload(ctx, sel, v)
}

func (ec *executionContext) marshalOAddPackageVersionPayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddPackageVersionPayload(ctx context.Context, sel ast.SelectionSet, v *model.AddPackageVersionPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AddPackageVersionPayload(ctx, sel, v)
}

func (ec *executionContext) marshalOAddProgrammingLanguagePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAddProgrammingLanguagePayload(ctx context.Context, sel ast.SelectionSet, v *model.AddProgrammingLanguagePayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AddProgrammingLanguagePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAuthRule2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAuthRule(ctx context.Context, v interface{}) ([]*model.AuthRule, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.AuthRule, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOAuthRule2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAuthRule(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAuthRule2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐAuthRule(ctx context.Context, v interface{}) (*model.AuthRule, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAuthRule(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*v)
}

func (ec *executionContext) unmarshalOContainsFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐContainsFilter(ctx context.Context, v interface{}) (*model.ContainsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputContainsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCustomHTTP2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐCustomHTTP(ctx context.Context, v interface{}) (*model.CustomHTTP, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCustomHTTP(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODateTime2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalODateTime2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODateTime2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalODateTime2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalODateTime2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODateTime2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalODateTimeRange2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDateTimeRange(ctx context.Context, v interface{}) (*model.DateTimeRange, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDateTimeRange(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODeleteLicensePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDeleteLicensePayload(ctx context.Context, sel ast.SelectionSet, v *model.DeleteLicensePayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeleteLicensePayload(ctx, sel, v)
}

func (ec *executionContext) marshalODeletePackagePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDeletePackagePayload(ctx context.Context, sel ast.SelectionSet, v *model.DeletePackagePayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeletePackagePayload(ctx, sel, v)
}

func (ec *executionContext) marshalODeletePackageTypePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDeletePackageTypePayload(ctx context.Context, sel ast.SelectionSet, v *model.DeletePackageTypePayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeletePackageTypePayload(ctx, sel, v)
}

func (ec *executionContext) marshalODeletePackageVersionPayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDeletePackageVersionPayload(ctx context.Context, sel ast.SelectionSet, v *model.DeletePackageVersionPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeletePackageVersionPayload(ctx, sel, v)
}

func (ec *executionContext) marshalODeleteProgrammingLanguagePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDeleteProgrammingLanguagePayload(ctx context.Context, sel ast.SelectionSet, v *model.DeleteProgrammingLanguagePayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeleteProgrammingLanguagePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalODgraphIndex2ᚕgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDgraphIndexᚄ(ctx context.Context, v interface{}) ([]model.DgraphIndex, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]model.DgraphIndex, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDgraphIndex2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDgraphIndex(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODgraphIndex2ᚕgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDgraphIndexᚄ(ctx context.Context, sel ast.SelectionSet, v []model.DgraphIndex) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDgraphIndex2githubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐDgraphIndex(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOFloat2ᚕᚖfloat64(ctx context.Context, v interface{}) ([]*float64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*float64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFloat2ᚖfloat64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFloat2ᚕᚖfloat64(ctx context.Context, sel ast.SelectionSet, v []*float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOFloat2ᚖfloat64(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloat(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalFloat(*v)
}

func (ec *executionContext) unmarshalOFloatRange2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐFloatRange(ctx context.Context, v interface{}) (*model.FloatRange, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFloatRange(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGenerateMutationParams2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐGenerateMutationParams(ctx context.Context, v interface{}) (*model.GenerateMutationParams, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGenerateMutationParams(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGenerateQueryParams2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐGenerateQueryParams(ctx context.Context, v interface{}) (*model.GenerateQueryParams, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGenerateQueryParams(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt2ᚕᚖint(ctx context.Context, v interface{}) ([]*int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOInt2ᚖint(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2ᚕᚖint(ctx context.Context, sel ast.SelectionSet, v []*int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOInt2ᚖint(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*v)
}

func (ec *executionContext) unmarshalOInt642ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOInt642ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt642ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOInt642ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt642ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt642ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalOInt64Range2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐInt64Range(ctx context.Context, v interface{}) (*model.Int64Range, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputInt64Range(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOIntRange2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐIntRange(ctx context.Context, v interface{}) (*model.IntRange, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputIntRange(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOIntersectsFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐIntersectsFilter(ctx context.Context, v interface{}) (*model.IntersectsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputIntersectsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLicense2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicense(ctx context.Context, sel ast.SelectionSet, v []*model.License) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLicense2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicense(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOLicense2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicense(ctx context.Context, sel ast.SelectionSet, v *model.License) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._License(ctx, sel, v)
}

func (ec *executionContext) marshalOLicenseAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseAggregateResult(ctx context.Context, sel ast.SelectionSet, v *model.LicenseAggregateResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LicenseAggregateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLicenseFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx context.Context, v interface{}) ([]*model.LicenseFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.LicenseFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOLicenseFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLicenseFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseFilter(ctx context.Context, v interface{}) (*model.LicenseFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLicenseFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLicenseHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseHasFilter(ctx context.Context, v interface{}) ([]*model.LicenseHasFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.LicenseHasFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOLicenseHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseHasFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOLicenseHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseHasFilter(ctx context.Context, sel ast.SelectionSet, v []*model.LicenseHasFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLicenseHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseHasFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOLicenseHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseHasFilter(ctx context.Context, v interface{}) (*model.LicenseHasFilter, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.LicenseHasFilter)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLicenseHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseHasFilter(ctx context.Context, sel ast.SelectionSet, v *model.LicenseHasFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLicenseOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseOrder(ctx context.Context, v interface{}) (*model.LicenseOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLicenseOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLicenseOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseOrderable(ctx context.Context, v interface{}) (*model.LicenseOrderable, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.LicenseOrderable)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLicenseOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseOrderable(ctx context.Context, sel ast.SelectionSet, v *model.LicenseOrderable) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLicenseRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseRef(ctx context.Context, v interface{}) ([]*model.LicenseRef, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.LicenseRef, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOLicenseRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseRef(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLicenseRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐLicenseRef(ctx context.Context, v interface{}) (*model.LicenseRef, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLicenseRef(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMode2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐMode(ctx context.Context, v interface{}) (*model.Mode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Mode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMode2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐMode(ctx context.Context, sel ast.SelectionSet, v *model.Mode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOMultiPolygonRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐMultiPolygonRef(ctx context.Context, v interface{}) (*model.MultiPolygonRef, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMultiPolygonRef(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONearFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐNearFilter(ctx context.Context, v interface{}) (*model.NearFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNearFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPackage2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackage(ctx context.Context, sel ast.SelectionSet, v []*model.Package) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPackage2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPackage2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackage(ctx context.Context, sel ast.SelectionSet, v *model.Package) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Package(ctx, sel, v)
}

func (ec *executionContext) marshalOPackageAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageAggregateResult(ctx context.Context, sel ast.SelectionSet, v *model.PackageAggregateResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PackageAggregateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPackageFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx context.Context, v interface{}) ([]*model.PackageFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PackageFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOPackageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPackageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageFilter(ctx context.Context, v interface{}) (*model.PackageFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPackageFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPackageHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageHasFilter(ctx context.Context, v interface{}) ([]*model.PackageHasFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PackageHasFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOPackageHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageHasFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPackageHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageHasFilter(ctx context.Context, sel ast.SelectionSet, v []*model.PackageHasFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPackageHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageHasFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOPackageHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageHasFilter(ctx context.Context, v interface{}) (*model.PackageHasFilter, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PackageHasFilter)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPackageHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageHasFilter(ctx context.Context, sel ast.SelectionSet, v *model.PackageHasFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPackageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageOrder(ctx context.Context, v interface{}) (*model.PackageOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPackageOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPackageOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageOrderable(ctx context.Context, v interface{}) (*model.PackageOrderable, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PackageOrderable)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPackageOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageOrderable(ctx context.Context, sel ast.SelectionSet, v *model.PackageOrderable) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPackagePatch2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackagePatch(ctx context.Context, v interface{}) (*model.PackagePatch, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPackagePatch(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPackageType2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageType(ctx context.Context, sel ast.SelectionSet, v []*model.PackageType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPackageType2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPackageType2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageType(ctx context.Context, sel ast.SelectionSet, v *model.PackageType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PackageType(ctx, sel, v)
}

func (ec *executionContext) marshalOPackageTypeAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeAggregateResult(ctx context.Context, sel ast.SelectionSet, v *model.PackageTypeAggregateResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PackageTypeAggregateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPackageTypeFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx context.Context, v interface{}) ([]*model.PackageTypeFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PackageTypeFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOPackageTypeFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPackageTypeFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeFilter(ctx context.Context, v interface{}) (*model.PackageTypeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPackageTypeFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPackageTypeHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeHasFilter(ctx context.Context, v interface{}) ([]*model.PackageTypeHasFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PackageTypeHasFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOPackageTypeHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeHasFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPackageTypeHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeHasFilter(ctx context.Context, sel ast.SelectionSet, v []*model.PackageTypeHasFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPackageTypeHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeHasFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOPackageTypeHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeHasFilter(ctx context.Context, v interface{}) (*model.PackageTypeHasFilter, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PackageTypeHasFilter)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPackageTypeHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeHasFilter(ctx context.Context, sel ast.SelectionSet, v *model.PackageTypeHasFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPackageTypeOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeOrder(ctx context.Context, v interface{}) (*model.PackageTypeOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPackageTypeOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPackageTypeOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeOrderable(ctx context.Context, v interface{}) (*model.PackageTypeOrderable, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PackageTypeOrderable)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPackageTypeOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeOrderable(ctx context.Context, sel ast.SelectionSet, v *model.PackageTypeOrderable) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPackageTypeRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageTypeRef(ctx context.Context, v interface{}) (*model.PackageTypeRef, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPackageTypeRef(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPackageVersion2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersion(ctx context.Context, sel ast.SelectionSet, v []*model.PackageVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPackageVersion2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPackageVersion2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersion(ctx context.Context, sel ast.SelectionSet, v *model.PackageVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PackageVersion(ctx, sel, v)
}

func (ec *executionContext) marshalOPackageVersionAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionAggregateResult(ctx context.Context, sel ast.SelectionSet, v *model.PackageVersionAggregateResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PackageVersionAggregateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPackageVersionFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx context.Context, v interface{}) ([]*model.PackageVersionFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PackageVersionFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOPackageVersionFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPackageVersionFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionFilter(ctx context.Context, v interface{}) (*model.PackageVersionFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPackageVersionFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPackageVersionHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionHasFilter(ctx context.Context, v interface{}) ([]*model.PackageVersionHasFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PackageVersionHasFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOPackageVersionHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionHasFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPackageVersionHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionHasFilter(ctx context.Context, sel ast.SelectionSet, v []*model.PackageVersionHasFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPackageVersionHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionHasFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOPackageVersionHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionHasFilter(ctx context.Context, v interface{}) (*model.PackageVersionHasFilter, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PackageVersionHasFilter)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPackageVersionHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionHasFilter(ctx context.Context, sel ast.SelectionSet, v *model.PackageVersionHasFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPackageVersionOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionOrder(ctx context.Context, v interface{}) (*model.PackageVersionOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPackageVersionOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPackageVersionOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionOrderable(ctx context.Context, v interface{}) (*model.PackageVersionOrderable, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PackageVersionOrderable)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPackageVersionOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionOrderable(ctx context.Context, sel ast.SelectionSet, v *model.PackageVersionOrderable) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPackageVersionRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionRef(ctx context.Context, v interface{}) ([]*model.PackageVersionRef, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PackageVersionRef, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOPackageVersionRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionRef(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPackageVersionRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPackageVersionRef(ctx context.Context, v interface{}) (*model.PackageVersionRef, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPackageVersionRef(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPointRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPointRef(ctx context.Context, v interface{}) (*model.PointRef, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPointRef(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPolygonRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐPolygonRef(ctx context.Context, v interface{}) (*model.PolygonRef, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPolygonRef(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProgrammingLanguage2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguage(ctx context.Context, sel ast.SelectionSet, v []*model.ProgrammingLanguage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProgrammingLanguage2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOProgrammingLanguage2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguage(ctx context.Context, sel ast.SelectionSet, v *model.ProgrammingLanguage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProgrammingLanguage(ctx, sel, v)
}

func (ec *executionContext) marshalOProgrammingLanguageAggregateResult2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageAggregateResult(ctx context.Context, sel ast.SelectionSet, v *model.ProgrammingLanguageAggregateResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProgrammingLanguageAggregateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProgrammingLanguageFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx context.Context, v interface{}) ([]*model.ProgrammingLanguageFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.ProgrammingLanguageFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOProgrammingLanguageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProgrammingLanguageFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageFilter(ctx context.Context, v interface{}) (*model.ProgrammingLanguageFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProgrammingLanguageFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProgrammingLanguageHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageHasFilter(ctx context.Context, v interface{}) ([]*model.ProgrammingLanguageHasFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.ProgrammingLanguageHasFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOProgrammingLanguageHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageHasFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOProgrammingLanguageHasFilter2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageHasFilter(ctx context.Context, sel ast.SelectionSet, v []*model.ProgrammingLanguageHasFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProgrammingLanguageHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageHasFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOProgrammingLanguageHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageHasFilter(ctx context.Context, v interface{}) (*model.ProgrammingLanguageHasFilter, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ProgrammingLanguageHasFilter)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProgrammingLanguageHasFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageHasFilter(ctx context.Context, sel ast.SelectionSet, v *model.ProgrammingLanguageHasFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOProgrammingLanguageOrder2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageOrder(ctx context.Context, v interface{}) (*model.ProgrammingLanguageOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProgrammingLanguageOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProgrammingLanguageOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageOrderable(ctx context.Context, v interface{}) (*model.ProgrammingLanguageOrderable, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ProgrammingLanguageOrderable)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProgrammingLanguageOrderable2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageOrderable(ctx context.Context, sel ast.SelectionSet, v *model.ProgrammingLanguageOrderable) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOProgrammingLanguageRef2ᚕᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageRef(ctx context.Context, v interface{}) ([]*model.ProgrammingLanguageRef, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.ProgrammingLanguageRef, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOProgrammingLanguageRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageRef(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProgrammingLanguageRef2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐProgrammingLanguageRef(ctx context.Context, v interface{}) (*model.ProgrammingLanguageRef, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProgrammingLanguageRef(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalOStringHashFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐStringHashFilter(ctx context.Context, v interface{}) (*model.StringHashFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStringHashFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOStringRange2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐStringRange(ctx context.Context, v interface{}) (*model.StringRange, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStringRange(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOStringTermFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐStringTermFilter(ctx context.Context, v interface{}) (*model.StringTermFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStringTermFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpdatePackagePayload2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐUpdatePackagePayload(ctx context.Context, sel ast.SelectionSet, v *model.UpdatePackagePayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdatePackagePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWithinFilter2ᚖgithubᚗcomᚋvalllabhᚋsecurityᚑcliᚋgraphᚋmodelᚐWithinFilter(ctx context.Context, v interface{}) (*model.WithinFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWithinFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
